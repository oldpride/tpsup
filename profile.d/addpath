local OPTIND OPTARG o quiet usage prog old new value var

prog=${FUNCNAME[1]}

usage="
usage: 
   $prog [-r] [-e var] [-v] path

   add a new element to env var, eg, PATH

   -e var   change this env var. default to PATH
   -r       add path to rear. default to front
   -v       verbose mode

   example:
      $prog /usr/local/bin
      $prog -r /usr/local/bin
      $prog -e LD_LIBRARY_PATH /usr/local/lib
      $prog -e PYTHONPATH \`pwd\`/macro

"

quiet=N
rear=N
var=PATH
verbose=N
flag="-q"

while getopts vre: o; do
   case "$o" in
   v)
      verbose=Y
      flag=""
      ;;
   r)
      rear=Y
      ;;
   e) var=$OPTARG ;;
   *)
      echo "unknow switch. $usage" >&2
      return 1
      ;;
   esac
done

shift $((OPTIND - 1))

if [ $# -ne 1 ]; then
   echo "wrong number of args: expected 1, actual $#"
   echo "$usage"
   return
fi

value=$1

old="eval echo \$$var"

if [ "$verbose" = "Y" ]; then
   echo "old $var: $($old)"
fi

# convert path to full path
value=$(readlink -f "$value")

sep=:
# if we are in windows and the enve var is not PATH, we should
#    1. use ; as separator
#    2. use native path
if [ "$var" != "PATH" ]; then
   uname=$(uname)
   # cygwin: CYGWIN_NT-10.0-26200
   # gitbash: MINGW64_NT-10.0-26200
   # vscode: MINGW_64_NT-10.0-26200
   # antigravity: MINGW_64_NT-10.0-26200
   if [[  $uname =~ _NT- ]]; then
      sep=';'
      value=$(convertpath -t batch "$value")
   fi
fi


if [ "$rear" = "Y" ]; then
   new="$($old)$sep$value"
else
   new="$value$sep$($old)"
fi

# reduce $var
# this caused error in perlenv in cygwin

if [ "$verbose" = "Y" ]; then
   echo "new $var: $new"
fi

if [ "X$new" = "X$$old" ]; then
   if [ "$verbose" = "Y" ]; then
      echo "no change"
   fi
   return
fi

export $var="$new"

#!/usr/bin/env perl

use strict;
use warnings;
#use TPSUP::SWAGGER qw();
use Carp;

# don't add 'my' in front of below because the variable is declared in the caller.
our $our_cfg = {
   # position_args => [ 'base', 'op' ],
   minimal_args => 2,

   extra_args => {
      'nojson'  => 'nojson',     # -nojson
   },

   pre_checks => [
      # you need this in corporate network
      #{ 
      #   check      => 'exists($ENV{HTTPS_CA_DIR})',
      #   suggestion => 'run: export HTTPS_CA_DIR=/etc/ssl/certs',
      #},
   ],

   package => 'TPSUP::SWAGGER',
   # runs TPSUP::SWAGGER::tpbatch_code() by default

   # usage_example => "",   # usage_example's default is in package SWAGGER.pm

   # sub_url vs sub_ui
   #    sub_url is to be used by curl command
   #    sub_ui  is user interface where use manually click swagger menu on web portal.
   # sub_ui is default to share the first part of sub_url, example
   #    sub_url: app1/api/run_myop1_1 
   #    sub_ui : app1/swagger-ui
   # we use default sub_ui below

   cfg => {
      mybase1 =>{
         base_urls => ['https://myhost1.abc.com:9100'],
         entry     => 'swagger-tian',
         op        => {
            myop1_1 => {
               num_args  => 1,
               sub_url   => 'app1/api/run_myop1_1',
               json      => 1,
               method    => 'POST',
               post_data => '{{A0}}',
               # json requires double string for its strings. therefore, we use single
               # quote below.
               validator => qq('{{A0}}' =~ /hello/), 
               comment   => 'run myop1_1',
               test_str  => [ "abc",  qq('{"hello world"}') ],  # two tests here
            },
            myop1_2 => {
               sub_url   => 'app1/api/run_myop1_2',
               json      => 1,
               method    => 'POST',
               post_data => qq('["hard coded"]'),
               comment   => 'run myop1',
            },
            myop1_3 => {
               num_args  => 1,
               sub_url   => 'app1/api/run_myop1_3',
               validator => 'swagger_test_validator("{{A0}}")',
               comment   => 'run myop1',
               test_str  => ['hello', 'world'],
            },
         },
      },

      mybase2 => {
         base_urls => ['https://myhost1.abc.com:9102', 'https://myhost2.abc.com:9102'],
        #  entry     => 'swagger-tian',
        entry_func => \&TPSUP::SWAGGER::get_entry,
         op        => {
            myop2_1 => {
               num_args => 2,
               sub_url  => 'app2/api/run_myop2/{{A0}}/{{A1}}',
               Accept   => 'text/xml',
               comment  => 'run myop2_1',
               test_str  => ['my_arg0 my_arg1', 'your_arg0 your_arg1'],
            },
         },
      },
   },
};

# prefix "TPSUP::SWAGGER" when defining sub here because sub default to "TPSUP::BATCH".
#   - this script is parsed by TPSUP::BATCH, so by default the subs go to TPSUP::BATCH.
#   - but the subs will be called TPSUP::SWAGGER, therefore, needs to be seen by it.
sub TPSUP::SWAGGER::swagger_test_validator {
   my ($a, $opt) = @_;

   if ($a =~ /hello/) {
      print "validating $a: matched hello\n";
      return 1;
   } else {
      print "validating $a: not matched hello\n";
      return 0;
   }
}

$TPSUP::SWAGGER::parsed_pattern_file = {};

sub TPSUP::SWAGGER::parse_pattern_file {
    my ($pattern_file, $opt) = @_;

    if ( ! exists ($TPSUP::SWAGGER::parsed_pattern_file->{$pattern_file}) ) {
        my $ref = {};

        # pattern file format:
        #   login1:pattern1
        #   login2:pattern2
        open my $fh, "<", $pattern_file or croak "cannot open $pattern_file: $!";
        while (my $line = <$fh>) {
            next if $line =~ /^\s*#/; # skip comment
            next if $line =~ /^\s*$/; # skip empty line
            chomp $line;

            # remove dos ^M
            $line =~ s/\r//g;

            my ($login, $pattern) = split /,/, $line, 2;
            $ref->{$login} = $pattern;
        }

        close $fh;

        $TPSUP::SWAGGER::parsed_pattern_file->{$pattern_file} = $ref;
        # print "parsed_pattern_file=", Data::Dumper::Dumper($TPSUP::SWAGGER::parsed_pattern_file), "\n";
    }

    return $TPSUP::SWAGGER::parsed_pattern_file->{$pattern_file};
}

sub TPSUP::SWAGGER::get_entry {
   my ($cfg, $dict, $opt) = @_;

   # print "cfg=", Data::Dumper->Dump([$cfg], ['cfg']), "\n";
   # print "dict=", Data::Dumper->Dump([$dict], ['dict']), "\n";

   my $pattern_file = $cfg->{meta}->{cfg_abs_path};
   $pattern_file =~ s/_batch.cfg/_pattern.cfg/;
   #    print "pattern_file=$pattern_file\n";
   my $pattern_by_login = TPSUP::SWAGGER::parse_pattern_file($pattern_file, $opt);
   #    print "pattern_by_login=", Data::Dumper::Dumper($pattern_by_login), "\n";

   for my $login (keys %$pattern_by_login) {
      my $pattern = $pattern_by_login->{$login};
      # print "login=$login, pattern=$pattern, sub_url=$cfg->{sub_url}\n";

      if ($cfg->{sub_url} =~ /$pattern/) {
         return $login;
      }
   }

   croak "cannot find login for $cfg->{sub_url} in $pattern_file";
}

#!/usr/bin/perl

use warnings;
use strict;
use Data::Dumper;
use Getopt::Long;
use Carp;

# use TPSUP::UTIL qw(tpfind);
use TPSUP::FILE qw(tpfind);

my $prog = $0;
$prog =~ s:.*/::;

sub usage {
    my ($message) = @_;

    print "$message\n" if $message;

    print STDERR << "END";
usage:

   find path1 path2 ...

   This script is to mimic find(1) command but enhanced with more expresssions in Perl style.

   -m       match_exp       filter files: eg '\$path =~ /cmd-exe\$/'

   -he      handle_exp      eg '\$path =~ /suppress-(in|out)'

   -ha      handle_act      eg 'chkperl(\$value)'

   -fe      flow_exp        flow control expression

   -fd      flow_dir        flow control direction, eg, 'prune', 'exit'

   -print                   print the paths that the script has browsed
   -ls                      print the paths that the script has browsed, 
                            with ls -l
   -dump                    print the paths that the script has browsed, 
                            with Data::Dumper

   -maxdepth number         max depth
   -maxcount number         max count

   variables: path type mode uid gid size mtime owner group now

examples:

   # print the dir tree
   $prog -maxdepth 0 \$TPSUP
   $prog -maxdepth 1 \$TPSUP
   $prog -maxdepth 1 \$TPSUP -ls
   $prog -maxdepth 1 \$TPSUP -dump

   # filter files
   $prog -maxdepth 1 -m '\$path =~ /python3\$/' \$TPSUP

   # use handlers, note: use '!' before system() call which returns 0 when successful.
   $prog -maxdepth 1 -he '\$path =~ /python/' -ha '!system("ls -l \$path")' \$TPSUP
   
   # flow control
   $prog -fe '\$path =~ /autopath|python|scripts|proj|lib|i86pc/' -fd 'prune' \$TPSUP

   $prog -fe '\$path =~ m:/scripts/:' -fd 'exit' \$TPSUP

   # use handlers as a filter
   $prog -he '\$path =~ /scripts/' -ha 'print "\$path\\n"' \$TPSUP

   # owner
   $prog -he '\$owner ne "gpt"' -ha 'print "\$path\\n"' \$TPSUP

   #  mtime/now. eg, file changed yesterday, one day is 86400 seconds
   $prog -he '\$mtime<\$now-86400 && \$mtime>\$now-(2*86400)' -ha 'my \$str=localtime(\$mtime); print "\$str \$path\\n"' \$TPSUP

   # mode, eg, file is writable
   $prog -he '\$mode & 0222' -ha 'printf("0\%o \%s\\n", \$mode, \$path)' \$TPSUP

   # mode, eg, file not executable
   $prog -he '!(\$mode & 0111)' -ha 'printf("0\%o \%s\\n", \$mode, \$path)' \$TPSUP

   # size, eg, file is bigger than 100K
   $prog -he '\$size >100000' -ha 'printf("\%d \%s\\n", \$size, \$path)' \$TPSUP

   # ifh(), ofh(): open file handler for input and output, the following find all bash scripts
   # notes:close \$fh failed on solaris on an .gz file, if close is the last command, append 'nop'
   $prog -he '\$type eq "file"' -ha '\$fh=ifh(\$path); \$line=<\$fh>; print "\$path,\$line" if \$line =~ m:^#!.#/bash\$:; close \$fh; nop' \$TPSUP

Note: perl system() return 0 when successful, but in perl expression, 0 means false, failure.
   # the following command find scripts (starting with #!), with mode not equal to 0755 
   # note: 
   #     - the ! before the system() call
   #     - use plenty of () to clarify the logic
   #     - neither cygwin nor gitbash handle the mode well. don't use below command there.
   
   $prog -he '(\$type eq "file") && ((\$mode & 0755) != 0755) && (\$fh=ifh(\$path)) && (\$line=<\$fh>) && (\$line=~/^#!/)' -ha '!system("ls -l \$path")' \$TPSUP

   $prog -he '(\$type eq "file") && ((\$mode & 0755) != 0755) && (\$fh=ifh(\$path)) && (\$line=<\$fh>) && (\$line=~/^#!/)' -ha '!system("chmod 755 \$path")' \$TPSUP 

   # or all-in-1 command
   $prog -he '(\$type eq "file") && ((\$mode & 0755) != 0755) && (\$fh=ifh(\$path)) && (\$line=<\$fh>) && (\$line=~/^#!/)' -ha '!system("ls -l \$path;chmod 755 \$path;ls -l \$path")' \$TPSUP

END

    exit 1;
}

my $verbose;

my @paths;
my @MatchExps;
my @HandleExps;
my @HandleActs;
my @FlowExps;
my @FlowDirs;
my $print;
my $find_ls;
my $find_dump;
my $maxdepth;

GetOptions(
    'v+'         => \$verbose,      # increment $verbose by 1 for each -v
    'print'      => \$print,
    'ls'         => \$find_ls,
    'dump'       => \$find_dump,
    'm=s'        => \@MatchExps,
    'he=s'       => \@HandleExps,
    'ha=s'       => \@HandleActs,
    'fe=s'       => \@FlowExps,
    'fd=s'       => \@FlowDirs,
    'maxdepth=s' => \$maxdepth,
) || usage("cannot parse command line: $!");

usage("wrong number of args") if !@ARGV;

my $ret = tpfind(
    \@ARGV,
    {
        verbose        => $verbose,
        paths          => \@paths,
        MatchExps      => \@MatchExps,
        HandleExps     => \@HandleExps,
        HandleExps     => \@HandleExps,
        HandleActs     => \@HandleActs,
        FlowExps       => \@FlowExps,
        FlowDirs       => \@FlowDirs,
        RecursivePrint => $print,
        find_ls        => $find_ls,
        find_dump      => $find_dump,
        MaxDepth       => $maxdepth,
    }
);

my $error = $ret->{error} || 0;

print STDERR "Total $error ERRORS\n" if $verbose || $error;

exit 0;

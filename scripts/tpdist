#!/usr/bin/perl

my $version = '7.3';
my ($expected_peer_protocol) = ($version =~ /^(\d+)/);

use warnings;
use strict;
use Data::Dumper;
use Getopt::Long;
use strict;
use Carp;
use IO::Socket::INET;
use IO::Select;
use Socket;
use POSIX;

my $timeout = 300;
my $idle = 600;
my $maxtry = 3;
my $interval = 5;

my $prog = $0; $prog =~ s:.*/::;

# we cannot copy root dir
# root dirs: /, //, C:, C:/, /cygdrive/c, /cygdrive/c/,
my $root_dir_pattern = '^([a-zA-Z]:[/]*|[/]+|[/]+cygdrive[/]+[^/]+[/]*)$';
my $abs_path_pattern = '^([a-zA-Z]:[/]*|[/]+|[/]+cygdrive[/]+[^/]+[/]*)';

my @crctab = (
   0x00000000,
   0x04c11db7, 0x09823b6e, 0x0d4326d9, 0x130476dc, 0x17c56b6b,
   0x1a864db2, 0x1e475005, 0x2608edb8, 0x22c9f00f, 0x2f8ad6d6,
   0x2b4bcb61, 0x350c9b64, 0x31cd86d3, 0x3c8ea00a, 0x384fbdbd,
   0x4c11db70, 0x48d0c6c7, 0x4593e01e, 0x4152fda9, 0x5f15adac,
   0x5bd4b01b, 0x569796c2, 0x52568b75, 0x6a1936c8, 0x6ed82b7f,
   0x639b0da6, 0x675a1011, 0x791d4014, 0x7ddc5da3, 0x709f7b7a,
   0x745e66cd, 0x9823b6e0, 0x9ce2ab57, 0x91a18d8e, 0x95609039,
   0x8b27c03c, 0x8fe6dd8b, 0x82a5fb52, 0x8664e6e5, 0xbe2b5b58,
   0xbaea46ef, 0xb7a96036, 0xb3687d81, 0xad2f2d84, 0xa9ee3033,
   0xa4ad16ea, 0xa06c0b5d, 0xd4326d90, 0xd0f37027, 0xddb056fe,
   0xd9714b49, 0xc7361b4c, 0xc3f706fb, 0xceb42022, 0xca753d95,
   0xf23a8028, 0xf6fb9d9f, 0xfbb8bb46, 0xff79a6f1, 0xe13ef6f4,
   0xe5ffeb43, 0xe8bccd9a, 0xec7dd02d, 0x34867077, 0x30476dc0,
   0x3d044b19, 0x39c556ae, 0x278206ab, 0x23431b1c, 0x2e003dc5,
   0x2ac12072, 0x128e9dcf, 0x164f8078, 0x1b0ca6a1, 0x1fcdbb16,
   0x018aeb13, 0x054bf6a4, 0x0808d07d, 0x0cc9cdca, 0x7897ab07,
   0x7c56b6b0, 0x71159069, 0x75d48dde, 0x6b93dddb, 0x6f52c06c,
   0x6211e6b5, 0x66d0fb02, 0x5e9f46bf, 0x5a5e5b08, 0x571d7dd1,
   0x53dc6066, 0x4d9b3063, 0x495a2dd4, 0x44190b0d, 0x40d816ba,
   0xaca5c697, 0xa864db20, 0xa527fdf9, 0xa1e6e04e, 0xbfa1b04b,
   0xbb60adfc, 0xb6238b25, 0xb2e29692, 0x8aad2b2f, 0x8e6c3698,
   0x832f1041, 0x87ee0df6, 0x99a95df3, 0x9d684044, 0x902b669d,
   0x94ea7b2a, 0xe0b41de7, 0xe4750050, 0xe9362689, 0xedf73b3e,
   0xf3b06b3b, 0xf771768c, 0xfa325055, 0xfef34de2, 0xc6bcf05f,
   0xc27dede8, 0xcf3ecb31, 0xcbffd686, 0xd5b88683, 0xd1799b34,
   0xdc3abded, 0xd8fba05a, 0x690ce0ee, 0x6dcdfd59, 0x608edb80,
   0x644fc637, 0x7a089632, 0x7ec98b85, 0x738aad5c, 0x774bb0eb,
   0x4f040d56, 0x4bc510e1, 0x46863638, 0x42472b8f, 0x5c007b8a,
   0x58c1663d, 0x558240e4, 0x51435d53, 0x251d3b9e, 0x21dc2629,
   0x2c9f00f0, 0x285e1d47, 0x36194d42, 0x32d850f5, 0x3f9b762c,
   0x3b5a6b9b, 0x0315d626, 0x07d4cb91, 0x0a97ed48, 0x0e56f0ff,
   0x1011a0fa, 0x14d0bd4d, 0x19939b94, 0x1d528623, 0xf12f560e,
   0xf5ee4bb9, 0xf8ad6d60, 0xfc6c70d7, 0xe22b20d2, 0xe6ea3d65,
   0xeba91bbc, 0xef68060b, 0xd727bbb6, 0xd3e6a601, 0xdea580d8,
   0xda649d6f, 0xc423cd6a, 0xc0e2d0dd, 0xcda1f604, 0xc960ebb3,
   0xbd3e8d7e, 0xb9ff90c9, 0xb4bcb610, 0xb07daba7, 0xae3afba2,
   0xaafbe615, 0xa7b8c0cc, 0xa379dd7b, 0x9b3660c6, 0x9ff77d71,
   0x92b45ba8, 0x9675461f, 0x8832161a, 0x8cf30bad, 0x81b02d74,
   0x857130c3, 0x5d8a9099, 0x594b8d2e, 0x5408abf7, 0x50c9b640,
   0x4e8ee645, 0x4a4ffbf2, 0x470cdd2b, 0x43cdc09c, 0x7b827d21,
   0x7f436096, 0x7200464f, 0x76c15bf8, 0x68860bfd, 0x6c47164a,
   0x61043093, 0x65c52d24, 0x119b4be9, 0x155a565e, 0x18197087,
   0x1cd86d30, 0x029f3d35, 0x065e2082, 0x0b1d065b, 0x0fdc1bec,
   0x3793a651, 0x3352bbe6, 0x3e119d3f, 0x3ad08088, 0x2497d08d,
   0x2056cd3a, 0x2d15ebe3, 0x29d4f654, 0xc5a92679, 0xc1683bce,
   0xcc2b1d17, 0xc8ea00a0, 0xd6ad50a5, 0xd26c4d12, 0xdf2f6bcb,
   0xdbee767c, 0xe3a1cbc1, 0xe760d676, 0xea23f0af, 0xeee2ed18,
   0xf0a5bd1d, 0xf464a0aa, 0xf9278673, 0xfde69bc4, 0x89b8fd09,
   0x8d79e0be, 0x803ac667, 0x84fbdbd0, 0x9abc8bd5, 0x9e7d9662,
   0x933eb0bb, 0x97ffad0c, 0xafb010b1, 0xab710d06, 0xa6322bdf,
   0xa2f33668, 0xbcb4666d, 0xb8757bda, 0xb5365d03, 0xb1f740b4
);

my ($os_name, $nodename, $os_release, $os_version, $machine) = POSIX::uname();
my $tmpdir = ($os_name =~ /MINGW/i) ? "/tmp" : "/var/tmp"; # Git Bash's os_name is MINGW

my $cygwin;
$cygwin ++ if $os_name =~ /^CYGWIN/i;

my $encrypt_key;

sub usage {
   my ($message) = @_;

   print "$message\n" if $message;

   print <<"END";
Usage:

   normal mode: server waits to be pulled; client pulls.
     $prog server local_port
     $prog client remote_host remote_port remote_path1 remote_path2 ... local_dir

   reversed mode: server waits to take in data; client pushes.
     $prog server local_port  -reverse remote_port remote_path1 remote_path2 ... local_dir
     $prog client remote_host remoe_port -reverse

   If remote path is a relative path, it will be relative to remote user's home dir.

   WARNING: windows host doesn't preserve sym links. cygwin can handle sym link, but
            gitbash cannot. 
   
Common Switches (for both server and client):

   -v                 verbose mode.

   -version           print version

   -KeepTmpFile       keep tmp file for troubleshooting purpse.
                      default is not to keep tmp file

   -timeout seconds
                      time to wait for peer to finish a transaction, default to $timeout

   -tmpdir dir        default to $tmpdir. (current os_name=$os_name)
                      (Solaris/Linux/Cygwin default to /var/tmp, GitBash defaults to /tmp)

   -r|reverse         server-pull/client-push. default is server-push/client-pull             

   -enc|encrypt  key_string
                      use this string to encrypt. client and server must use the same key
                      in the same time. default is not to encrypt

   -PreserveFullPath  don't simplify full path, for example, windows network path
   -p                    //linux1.fios-router.home/tian
                      should be preserved as it is, not to be treated as
                          /linux1.fios-router.home/tian
                      noramlly we don't need this as the code is trying to sort it out

Passive-side Switches: (To-be Pulled, normal Server state)

   -allowhost file
   -denyhost file
                      file contains allowed/deny host or ip. one per line,
                      lines stars with # is comment
                      default:
                          \$HOME/.tpsup/tpdist_allowhost.txt
                          \$HOME/.tpsup/tpdist_denyhost.txt

   -allowfile file
   -denyfile file
                      file contains allowed/deny dir or file, one per line, 
                      lines stars with # is comment
                      default:
                         \$HOME/.tpsup/tpdist_allowfile.txt
                         \$HOME/.tpsup/tpdist_denyfile.txt

   -idle seconds
                      max idle time before close server socket, default to $idle

Active-Side Switches: (To Pull, normal Client State)

   -n                 dryrun mode, list the filenames only

   -diff              diff mode. Besides listing file names as in dryrun mode, also
                      run diff if the file is on both sides. This mode will not
                      change any files.

   -maxsize           get up to this much bytes of total update, this is to limit
                      the size of update, meaning will drop some changes.
                      default is no limit.

   -match pattern     only files that matching this pattern (Perl RegEx style).
                      can be specified multiple times (in OR logic).

   -exclude pattern   exclude files that matching this pattern (Perl RegEx style)
                      can be specified multiple times (in OR logic).

   -deep              set to always use cksum to check. Default is fast check: if file size
                      and timestamp matches, we don't use cksum. cksum is time-consumig.

   -maxtry times
                      retry to connect to server, default to $maxtry

   -interval seconds
                      time between each retry, default to $interval;

   -quiet             suppress messages

Source-side switches

   -strict_tar        fatal any error from tar, normally because file changed during archive.
                      default is to allow changed files.

Examples:

   # to copy this script to a new host, 'host2', from this host, 'host1'
   host1\$ cat tpdist | tpnc -l 4444

   host2\$ tpnc host1 4444 > tpdist
        or
           telnet host1 4444 > tpdist
        or
           if the host has no telnet/nc/tpnc but has perl (eg cygwin), copy the netsuck
           (a very short perl program) first by copy-and-paste using an editor
           netsuck host1 4444 > tpdist

   host1\$ dist server 5555
   host2\$ tpdist client host1 5555 tpsup ~

END

   exit 1;
}

$| = 1;

my $verbose;
my $base;
my $KeepTmpFile;
my $denyfile;
my $allowfile;
my $denyhost;
my $allowhost;
my $dryrun;
my $diff;
my $maxsize = -1; # -1 means no limit
my @matches;
my @excludes;
my $deep = 0;
my $quiet;
my $reverse;
my $print_version;
my $PreserveFullPath;
my $strict_tar;

GetOptions(
   'v|verbose'       => \$verbose,
   'version'         => \$print_version,
   'r|reverse'       => \$reverse,
   'q|quiet'         => \$quiet,
   'KeepTmpFile'     => \$KeepTmpFile,
   'denyfile=s'      => \$denyfile,
   'allowfile=s'     => \$allowfile,
   'denyhost=s'      => \$denyhost,
   'allowhost=s'     => \$allowhost,
   'n|dryrun'        => \$dryrun,
   'diff'            => \$diff,
   'deep'            => \$deep,
   'maxsize=s'       => \$maxsize,
   'timeout=s'       => \$timeout,
   'idle=s'          => \$idle,
   'maxtry=s'        => \$maxtry,
   'interval=s'      => \$interval,
   'match=s'         => \@matches,
   'exclude=s'       => \@excludes,
   'tmpdir=s'        => \$tmpdir,
   'enc|encrypt=s'   => \$encrypt_key,
   'p|PreserveFullPath'=> \$PreserveFullPath,
   'strict_tar'      => \$strict_tar,
) || usage ("cannot parse command line: $!");

if ($print_version) {
   print "version $version\n";
   exit 0;
}

usage("wrong number of args") if @ARGV < 2;

die "cannot be both quite and verbose" if $quiet && $verbose;

my $mode = shift @ARGV;

my $host;
my $port;
my $remote_paths;
my $local_dir;

my $homedir = get_homedir();
$verbose && print STDERR "homedir=$homedir\n";

my $old_pwd = `pwd`; chomp $old_pwd;

my $out_count = 0; # outgoing byte counter
my $in_count  = 0; # incoming byte counter 
my $key_index_by_tag = {
   in => 0,  # encrypt key index for incoming message
   out => 0, # encrypt key index for outgoing message
};

my $key_length;
my @key_array;
if ($encrypt_key) {
   @key_array = split //, $encrypt_key;
   $key_length = scalar(@key_array);
}
  
if ($mode eq 'server') {
   $port = shift @ARGV;

   if ($reverse) {
      usage("wrong number of args") if @ARGV < 2;
      $local_dir = pop @ARGV;
      @$remote_paths = @ARGV;
   } else {
      usage("wrong number of args") if @ARGV;
   }
} elsif ($mode eq 'client') {
   $host = shift @ARGV;
   $port = shift @ARGV;

   if ($reverse) {
      usage("wrong number of args") if @ARGV;
   } else {
      usage("wrong number of args") if @ARGV < 2;
      $local_dir = pop @ARGV;
      @$remote_paths = @ARGV;
   }
} else {
   usage("first arg must be either 'server' or 'client'");
}

if ( defined($local_dir) && -e $local_dir  && ! -d $local_dir) {
   print "ERROR: local_dir=$local_dir is not a directory\n";
   exit 1;
}

print "version=$version, protocol=$expected_peer_protocol\n";

umask(022);

my $user_specified = {
   allowfile => $allowfile,
    denyfile =>  $denyfile,
   allowhost => $allowhost,
    denyhost =>  $denyhost,
};

my $AccessMatrix = load_access($user_specified);
if ($verbose)  {
   print "AccessMatrix=", Dumper($AccessMatrix);
}   

if ($mode eq 'server') {
   # this is a server
   
   my $listener_socket = new IO::Socket::INET (
         LocalPort => $port,
         Proto => 'tcp',
         Listen => 5,
         Reuse => 1,
         Timeout => $idle,
   ) or die "ERROR in Socket Creation : $!\n";

   CONNECTION:
   while (1) {
      # waiting for new client connection.
      print "---------------------------------------------------- \n";
      print get_timestamp(), "Server Waiting for new client connection on port $port (max $idle seconds)\n";
      my $socket = $listener_socket->accept();

      if (! defined $socket) {
         print get_timestamp(), "No new client connection for $idle seconds. Server quits\n";
         exit 0;
      }

      # get the host and port number of newly connected client.
      my $peer_address = $socket->peerhost();
      my $peer_port = $socket->peerport();
      print "------------------------------------------------------- \n";
      print get_timestamp(), "Accepted new client connection from $peer_address:$peer_port\n";

      my @peer_hostnames;
      {
         # This function contacts the system's name-resolving service, returning a list of
         # information for the host ADDR of type ADDRTYPE, as follows
         # ($name, $aliases, $addrtype, $length, @addrs)

         #$ perl -e 'use Socket; use Data::Dumper; print Dumper(gethostbyaddr(inet_aton("10.152.106.193"), AF_INET)),"\n";'
         #$VAR1 = 'apps7.abc.com';
         # $VAR2 = 'apps7 nygapps3.abc.com nygapps3 nygapps4.abc.com nygapps4';
         #$VAR3 = 2;
         #$VAR4 = 4;
         #$VAR5 = '
         #j';
          
         my @a = gethostbyaddr(inet_aton("$peer_address"), AF_INET);
         push @peer_hostnames, $a[0] if $a[0];
         push @peer_hostnames, split / /, $a[1] if $a[1];
         push @peer_hostnames, $peer_address;
         push @peer_hostnames, "localhost" if $peer_address eq '127.0.0.1';
         print get_timestamp(), "peer_hostnames = ", join(" ", @peer_hostnames), "\n";
      }

      # reset key_index
      $key_index_by_tag->{in}  = 0; 
      $key_index_by_tag->{out}  = 0; 

      $in_count  = 0; 
      $out_count = 0;

      for my $h (($peer_address, @peer_hostnames)) {
         if (! is_allowed($h, $AccessMatrix->{host}, {verbose=>$verbose}) ) {
            print get_timestamp(), "$peer_address: $h is not allowed to connect to us.\n";
            socket_send($socket, "connection is not allowed\n");
            $socket->close();
            next CONNECTION;
         } 
      }

      # restore pwd as functions may chdir to other places
      chdir($old_pwd) || croak "cannot cd '$old_pwd'";

      if ($reverse) {
         to_pull($socket, $remote_paths, $local_dir, {verbose=>$verbose});
      } else {
         to_be_pulled($socket, {verbose=>$verbose, AllowDenyPatterns=>$AccessMatrix->{file}});
      }
   }
} else {
   # this is a client

   $quiet || print get_timestamp(), "connecting to server $host:$port\n";
   my $socket;
   for (my $i=0; $i<$maxtry; $i++) {
      $socket = new IO::Socket::INET (
                                       PeerHost => $host,
                                       PeerPort => $port,
                                       Proto => 'tcp',
                                      );
      last if $socket;
      print STDERR get_timestamp(), "Cannot connect to server $host:$port: $!.\n";
      if ($i<$maxtry-1) {
         print STDERR "   On $host please run\n";
         print STDERR "     tpdist server $port\n";
         print STDERR "     Will retry in $interval seconds for ", $maxtry-$i-1, " time(s)\n";
         sleep $interval;
      } else {
         exit 1;
      }
   }

   if ($reverse) {
      to_be_pulled($socket, {verbose=>$verbose, AllowDenyPatterns=>$AccessMatrix->{file}});
   } else {
      to_pull($socket, $remote_paths, $local_dir, {verbose=>$verbose});
   }
}

exit 0;

###########################################################
# subs
###########################################################

sub get_homedir {
   my $homedir = $ENV{HOME} ? $ENV{HOME} : glob("-");
   if (!$homedir) {
      # normally the above logic would work, it not, take the hassle
       
      my $user;
      { 
         my $line = `id`;
         #uid=9020(tian) gid=7296(uniz)
         ($user) = ( $line =~ /^.+?\((.+?)\)/ );
         die "cannot figure out user from 'id' command: $line" if !$user;
      }
   
      {
         my $line = `getent passwd $user`;
         #tian:x:9020:7296:Tianhua Han,APP,2254201:/home/tian:/bin/ksh
         my @a = split /:/, $line;
         $homedir = $a[7];
         die "cannot figure out home dir from getent passwd $user" if !$homedir;
      }
   }
   return $homedir;
}

sub load_access {
   my ($user_specified, $opt) = @_;

   my $matrix;

   for my $type (qw(host file)) {
      for my $access (qw(allow deny)) {
         my $key = "${access}${type}";
         my $file = $user_specified->{$key}                 ? $user_specified->{$key} :
                     (-f "$homedir/.tpsup/tpdist_$key.txt") ? "$homedir/.tpsup/tpdist_$key.txt" :
                                                               undef ;
         if ($file ) {
            my $patterns = read_security_file($file);
            if ($patterns) {
               $matrix->{$type}->{$access} = $patterns;
            } else {
               # why fatal here?
               # because if a file exists but is empty, for example, if the allow file exists but is
               # empty, should we allow all or allow none? this becomes ambiguous and prone to error!!
               print STDERR "FATAL: there is no settings in $file. It may mean 'allow all' or 'deny all'. To avoid ambiguity, either remove file or add settings.\n";
               exit 1;
            }
         }
      }
   }

   return $matrix;
}

sub tar_file_list {
   my ($front, $tar_file, $created_tar, $tar_list) = @_;

   my $cmd;
   if (!$created_tar) {
      $cmd = "cd '$front'; tar -cvf $tar_file -T $tar_list";
   } else {
      $cmd = "cd '$front'; tar -uvf $tar_file -T $tar_list";
   }
   $verbose && print get_timestamp(), "$cmd\n";
   system($cmd);
   my $perl_rc = $?;

   my $shell_rc;
   if ($perl_rc == - 1) {
      $shell_rc = 255;
   } else {
      $shell_rc =  $perl_rc;
      $shell_rc = $shell_rc & 0xffff;
      $shell_rc >>= 8;
   }
      
   # from man tar
   # 
   #  0  Successful termination.
   #
   #  1  Some files differ.  If tar was invoked with the --compare (--diff, -d) command
   #     line  option, this means that some files in the archive differ from their disk
   #     counterparts.  If tar was given one of  the  --create,  --append  or  --update
   #     options,  this  exit  code  means  that  some  files  were changed while being
   #     archived and so the resulting archive does not contain the exact copy  of  the
   #     file set.
   #
   #  2  Fatal error.  This means that some fatal, unrecoverable error occurred.

   return if $shell_rc == 0;
   return if $shell_rc == 1 && !$strict_tar;

   croak "$cmd failed";
}

sub get_timestamp {
   my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime(time);
   return sprintf("%04d%02d%02d %02d:%02d:%02d ", $year+1900, $mon+1, $mday, $hour, $min, $sec); 
}

sub read_security_file {
   my ($file, $opt) = @_;

   croak "cannot find $file" if ! -f $file;

   my @lines = `cat $file`;
   croak "cannot read $file" if $?;
   chomp @lines;

   my @patterns;
   for my $l (@lines) {
      next if $l =~ /^\s*$/;
      next if $l =~ /^\s*#/;

      $l =~ s/^\s+//;
      $l =~ s/\s+$//;

      push @patterns, qr/$l/; # pre-compile the pattern
   }
   return \@patterns;
}

my $tmp_index;

sub get_tmp_file {
   my ($basedir, $prefix, $opt) = @_;

   if ($opt->{chkSpace}) {
      #my $os = `uname -a`; chomp $os;

      my $found = `which df`;
      if ($? || !$found) {
         print STDERR "cannot find df command, skipped space check\n";
      } else {
         my $cmd = $os_name =~ /^Linux/ ? "df -kP $basedir" : "df -k $basedir";
         my @DF = `$cmd`;
         #$ df -k /var/tmp
         #Filesystem kbytes used avail capacity Mounted on
         #/ 4130542 2837486 1251751 70% /
         if ( ! $DF[1]) {
            carp "cmd='$cmd' failed".
            return undef;
         }
         chomp @DF;
         if (@DF == 3) {
            # some old solaris system split a long line into 2. therefore, we merge them
            $DF[1] = $DF[1] . " " . $DF[2];
         }

         my @a = split /\s+/, $DF[1];
         my $avail = $a[3];
         $avail *= 1024;
         if ($avail < $opt->{chkSpace}) {
            carp "$basedir doesn't have enough space, available=$avail, required=$opt->{chkSpace}";
            return undef;
         }
      }
   }

   my $id = `id`;
   my ($user) = ($id =~ /^.+?\((.+?)\)/ );

   my $yyyymmdd = `date +%Y%m%d`; chomp $yyyymmdd;
   my $HHMMSS = `date +%H%M%S`; chomp $HHMMSS;
   my $tmpdir = "$basedir/tmp_${user}";
   my $daydir = "$tmpdir/$yyyymmdd";

   if (! -d $daydir ) {
      my $cmd = "mkdir -p '$daydir'";
      system($cmd);
      die "cmd=$cmd failed" if $?;
      system("find $tmpdir -mount -mtime +7 -exec /bin/rm -fr {} \\;");
   }

   if ($opt->{AddIndex}) {
      if (!$tmp_index) {
         $tmp_index = 1;
      } else {
         $tmp_index++;
      }
   }

   if ($opt->{isDir} && "$opt->{isDir}" !~ /^[0nf]/i) {
      my $dir = "$daydir/$prefix.$HHMMSS.$$.dir";
      $dir .= ".$tmp_index" if $opt->{AddIndex};
      mkdir($dir) || return undef;
      return $dir;
   } else {
      my $file = "$daydir/$prefix.$HHMMSS.$$";
      $file .= ".$tmp_index" if $opt->{AddIndex};
      return $file;
   }
}

sub get_abs_path {
   my ($path) = @_;

   # we have to write our own get_abs_path because the default abs_path resolves # symbolic links, which is undesirable here.  # $ perl -e 'use Cwd 'abs_path'; print abs_path("tpsup/scripts/../autopath"), "\n";' # /home/tian/tpsup/autopath # $ perl -e 'use Cwd 'abs_path'; print abs_path("./tpsup/scripts/../autopath"), "\n";' # /home/tian/tpsup/autopath
   # $ perl -e 'use Cwd 'abs_path'; print abs_path(".//tpsup/scripts/../autopath/"), "\n";'
   # /home/tian/tpsup/autopath

   croak "path is no defined" if !$path;

   if ($path !~ /$abs_path_pattern/)  {
      my $cwd = getcwd();
      $path = "$cwd/$path";
   }
   
   {
      # If the path is dir and already exists, using "cd path; pwd" to find abs is the best way.
      # This also fixed this problem with the network path in windows, which starts with "//".
      # for example
      #    william@tianpc://linux1.fios-router.home/tian$ tpdist client localhost 5555 test.txt .
      #    ...
      #    20200717 16:07:09 cd '//linux1.fios-router.home/tian'
      #    ...
      my $saved_pwd = getcwd(); # save current path
      if (chdir($path)) {
         my $abs = getcwd(); 
         chdir($saved_pwd); # restore pwd before returning
         return $abs;
      }
   }

   if ($PreserveFullPath) {
      return $path;
   }
   # to test the Preserve switch, with vs without -p
   #    william@tianpc://linux1.fios-router.home/tian$ tpdist -p server 5555
   #    william@tianpc:/c/Users/william$ tpdist client localhost 5555 //linux1.fios-router.home/tian/test.txt .

   my $is_network_path = 0;
   if ($path =~ m:^//:) {
      # eg //linux1.fios-router.home/tian
      $is_network_path = 1;
   }

   my @a1 = split /\/+/, $path;
   shift @a1; # shift away the undef before the first /

   my @a2;
   for my $e (@a1) {
      if ($e eq '.') {
         # convert /a/./b to /a/b
         next;
      } elsif ($e eq '..' ) {
         # convert /a/b/../c to /a/c
         pop @a2;
         next;
      } else {
         push @a2, $e;
         next;
      }
   }

   my $newpath = $is_network_path ? '//' : '/';
   $newpath .= join('/', @a2);

   return $newpath;
}

sub build_dir_tree {
   my ($paths, $opt) = @_;

   my $AllowDenyPatterns = $opt->{AllowDenyPatterns};

   my $saved_cwd = getcwd();

   my $tree;

   for my $path (@$paths) {
      chdir($saved_cwd); # start from saved cwd
      
      if ($opt->{RelativeBase} && $path !~ m:^/: ) {
         # RelativeBase is from command line and only on the to-pull side.
         print get_timestamp(), "cd '$opt->{RelativeBase}'\n";
         if ( !chdir($opt->{RelativeBase}) ) {
            # if there is an error, we just print locally, not to send to remote side. 
            # therefore, we won't add the error into $tree.
            print get_timestamp(), "cd '$opt->{RelativeBase}' failed, $path is skipped.\n";
            next;
         }
      }

      # resolve * when filename has space
      # example:
      #    ls -1d  /cygdrive/c/users/william/My\ Documents/*txt     # works
      #    ls -1d  /cygdrive/c/users/william/'My Documents'/*txt    # works 
      #    ls -1d '/cygdrive/c/users/william/My Documents/*txt'     # doesn't work

      $path =~ s/(\s)/\\$1/g;   # escape the space

      my @globs = `/bin/ls -1d $path`;
      if ($? || !@globs) {
         print get_timestamp(), "/bin/ls -1d $path failed, skipped $path\n";
         $tree->{$path}->{skip} = "$path not found";
         next;
      }
      chomp @globs;

      if (!$quiet) {
         if ( scalar(@globs) != 1 || $globs[0] ne $path ) {
            # print only if globs actually made a difference
            print get_timestamp(), "resolved globs if any: $path=>", join(' ', @globs), "\n";
         }            
      }

      for my $p (@globs) {
         my $abs_path;

         if ($p !~ m:^/:) {
            # this is relative path
            if ($opt->{RelativeBase}) {
               $abs_path = get_abs_path("$opt->{RelativeBase}/$p");
               #$abs_path = "$opt->{RelativeBase}/$p";
            } else {
               $abs_path = get_abs_path("$saved_cwd/$p");
            }
         } else {
            # this is absolute path, still simplify eg. from a/../b to b 
            $abs_path = get_abs_path("$p")
         }

         if (!$abs_path) {
            print get_timestamp(), "cannot find abs_path for $p. skipped\n";
            $tree->{$p}->{skip} = "cannot find abs_path for $p";
            next;
         }

         # -l $abs_path allows a symbolic link pointing to nowhere
         if (! -e $abs_path && ! -l $abs_path) {
            print get_timestamp(), "cannot find $abs_path for $p\n";
            $tree->{$p}->{skip} = "abs path $abs_path for $p not found";
            next;
         }

         if ($abs_path =~ m!$root_dir_pattern!) {
            if ($p ne $abs_path) {
               $tree->{$p}->{skip} = "cannot handle root dir: $p, abs=$abs_path";
            } else {   
               $tree->{$p}->{skip} = "cannot handle root dir: $p";
            }
            next;
         }

         # $back is the starting point to compare, a relative path
         # $front is the parent path (absolute path)
         # example:
         #    $0 client host port /a/b/*.csv /c/d/e f/g
         # $back will be *.csv and e.
         # when comparing *.csv, server needs to 'cd /a/b'. client needs to 'cd /f/g'.
         # when comparing e, server needs to 'cd /c/d'. client needs to 'cd /f/g'.

         my ($front, $back);
         if ($abs_path =~ m:^(.*/)(.+):) {
            $front = $1;
            $back = $2;
         } else {
            $tree->{$p}->{skip} = "unexpected abs path: $abs_path. expecting front/back format";
            next;
         }

         # now that we have clearly identified $back, we should use it as key rather than
         # $abs_path or $p as key
         if (!is_allowed($abs_path, $AllowDenyPatterns, $opt)) {
            $tree->{$back}->{skip} = "not allowed";
            next;
         }

         $quiet || print get_timestamp(), "cd '$front'\n";
         if (! chdir($front) ) {
            $tree->{$back}->{skip} = "chdir($front) failed";
            next;
         }

         my $cmd = "find '$back' -mount -print";
         $quiet || print get_timestamp(), "$cmd\n";

         my $file_count = 0;
         my $fh;
         if ( ! open($fh, "$cmd |") ) {
            $tree->{$back}->{skip} = "$cmd failed";
            next;
         }

         FILES:
         while (<$fh>) {
            my $f = $_;
            chomp $f;

            $file_count ++;

            if ($file_count % 1000 == 0) {
               $quiet || print get_timestamp(), "checked $file_count files\n";
            }

            if (@{$opt->{matches}}) {
               my $matched;

               for my $m (@{$opt->{matches}}) {
                  if ($f =~ /$m/) {
                     $matched ++;
                     last;
                  }
               }

               next if !$matched;
            }

            if (@{$opt->{excludes}}) {
               for my $m (@{$opt->{excludes}}) {
                  if ($f =~ /$m/) {
                      next FILES;
                  }
               }
            }

            if ( !is_allowed($f, $AllowDenyPatterns, $opt) ) {
               $tree->{$f}->{skip} = "not allowed";
               next;
            }

            if ( ! -l $f && ! -r $f ) {
               if (!$cygwin || !test_read_by_open($f)) {
                  # why cygwin? see comment at test_read_by_open()
                  $tree->{$f}->{skip} = "no read access";
                  next;
               }
            }

            if ($tree->{$f}->{back}) {
               $tree->{$f}->{skip} = "duplicate target path: skip $front/$f";
               next;
            } else {
               $tree->{$f}->{back} = $back;
            }
            $tree->{$f}->{front} = $front;

            my ($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,$atime,$mtime,$ctime,$blksize,$blocks)
             = lstat($f);

            $tree->{$f}->{mtime} = $mtime;
            my $octal_mode = sprintf("0%o", ($mode & 07777));
            $tree->{$f}->{mode} = $octal_mode;

            if (-d $f && !-l $f) {
               # a link to dir is both a link and a dir.
               # (-d $f && !-l $f) gives us only the non-link dir
               $tree->{$f}->{type} = "dir";
               $tree->{$f}->{size} = 128; # hard coded
               $tree->{$f}->{test} = "dir"; # not much to test

               # check whether the dir is empty, need this info when making a tar.
               # if the directory is empty, we can tar the dir.
               # if the directory is not empty, and if we don't want to tar all files
               # in it, we can tar the dir.
               my $dfh;
               opendir($dfh, $f);

               if (!$dfh) {
                  print STDERR "cannot open dir $f\n";
               } else {
                  my @files_in_dir = grep { $_ ne '.' && $_ ne '..' } readdir($dfh);
                  $tree->{$f}->{DirEmpty} = 1 if !@files_in_dir;
               }
            } elsif (-l $f) {
               $tree->{$f}->{type} = "link";
               $tree->{$f}->{size} = 22; # hard coded
               $tree->{$f}->{test} = readlink($f);

               # we cannot change link's mtimes because lutimes is not implemented
               # in perl, therefore, we hard code it here
               $tree->{$f}->{mtime} = 0;

               # we cannot change link's mode because luchown is not implemented
               # in perl, therefore, we hard code it here
               my $mode = 0777;
               my $octal_mode = sprintf("0%o", ($mode & 07777));
               $tree->{$f}->{mode} = $octal_mode;

            } elsif (-f $f) {
               $tree->{$f}->{type} = "file";
               $tree->{$f}->{size} = $size;

               # cksum for {test} is delayed because it is too time consuming,
	       #$tree->{$f}->{test} = cksum($f);
            } else {
               print get_timestamp(), "skipped $front/$f because we cannot handle this type of file\n";
               $tree->{$f}->{skip} = "cannot handle this type of file";
               next;
            }
         }

         $quiet || print get_timestamp(), "checked $file_count files in total\n";
         close $fh;
      }
   }

   chdir($saved_cwd); # restore cwd

   return $tree;
}

sub is_allowed {
   my ($string, $AllowDenyPatterns, $opt) = @_;

   # handle deny_patterns first
   if (exists $AllowDenyPatterns->{deny}) {
      for my $pattern (@{$AllowDenyPatterns->{deny}}) {
         if ($string =~ /$pattern/) {
            $opt->{verbose} && print "$string is denied by $pattern\n";
            return 0
         }
      }
   }

   # handle allow_patterns 
   if (exists $AllowDenyPatterns->{allow}) {
      for my $pattern (@{$AllowDenyPatterns->{allow}}) {
         if ($string =~ /$pattern/) {
            $opt->{verbose} && print "$string is allowed by $pattern\n";
            return 1
         }
      }
      return 0;
   }

   return 1;
}

sub expect_socket {
   my ($socket, $patterns, $opt) = @_;

   my $type = ref $patterns;
   croak "\$patterns must be ref to ARRAY, yours is $type" if $type ne 'ARRAY';

   my $ExpectInterval = $opt->{ExpectInterval} ? $opt->{ExpectInterval} : 30;

   # turn on keepalive to quickly spot disconnection by remote side
   $socket->setsockopt(SOL_SOCKET, SO_KEEPALIVE, 1);

   my $total_data;
   my @matched;
   my @captures;
   my $num_patterns = scalar(@$patterns);
   my $BeginPattern = $opt->{BeginPattern} ? qr/$opt->{BeginPattern}/ : undef;
   my $BeginPatternMatched = 0;
   my $error_message;

   my $select = IO::Select->new($socket) or die "IO::Select $!";

   my $this_section_recv = 0;
   my $total_wait = 0;
   my $data;

   while (1) {
      if (! $select->can_read($ExpectInterval)) {
         if ($opt->{ExpectTimeout}) {
            $total_wait += $ExpectInterval;

            if ($total_wait >= $opt->{ExpectTimeout}) {
               print get_timestamp(), "expect_socket timed out after $opt->{ExpectTimeout} seconds\n";
               
               $error_message = "timed out after $opt->{ExpectTimeout} seconds. very likely wrong protocol. expecting $expected_peer_protocol.*";
               socket_send($socket, "$error_message\n");
               $socket->flush();
               last;
            }
         }

         socket_send($socket, "");
         $opt->{verbose} && print get_timestamp(), "no activity from remote in last $ExpectInterval seconds\n";
         next;
      }

      my $size = read($socket, $data, 1024000);

      if (!$size) {
         $error_message = "remote side closed socket";
         last;
      } else {
         $in_count += $size;
         $this_section_recv += $size;
         $data =  xor_encode($data, 'in');
         $opt->{verbose} && print get_timestamp(), "received $size byte(s), total=$in_count, this section so far $this_section_recv byte(s): $data\n";
         $total_data .= $data;

         if ($this_section_recv > 50 && $BeginPattern && !$BeginPatternMatched) {
            if ($total_data =~ /$BeginPattern/) {
               $BeginPatternMatched ++;
            } else {
               $error_message =  "begin string='" . substr($total_data, 0, 50) . 
                           "' doesn't match BeginPattern='$opt->{BeginPattern}'";
               last;
            }
         }

         my $all_matched = 1;
         for (my $i=0; $i<$num_patterns; $i++) {
            next if $matched[$i];

            if ($total_data =~ /$patterns->[$i]/s) {
               $opt->{verbose} && print "   matched $patterns->[$i]\n";
               $matched[$i] = 1;
               $captures[$i] = [$1, $2, $3];  # we normally only need $1.
            } else {
               $all_matched = 0;
            }
         }

         if ($all_matched) {
            print get_timestamp(), "received complete information from remote\n";
            last;
         }
      }
   }

   # turn off keepalive to lower network traffic
   $socket->setsockopt(SOL_SOCKET, SO_KEEPALIVE, 0);

   if ($error_message) {
      print get_timestamp(), "$error_message\n";
      print "   matched so far\n";
      for (my $i=0; $i<$num_patterns; $i++) {
           print "      pattern=$patterns->[$i]  ", $matched[$i] ? "matched" : "didn't match", "\n";
      }
      my $data_size = defined $total_data ? length($total_data) : 0;
      my $print_size = $data_size - 100 < 0 ? $data_size : 100;

      my $last_words = defined $total_data ?
                       substr($total_data, $data_size-$print_size, $print_size) : '';
      print "   Last words: $last_words\n";
      return undef;
   } else {
      return \@captures;
   }
}

my $bad_format_count = 0;

sub to_be_pulled {
   my ($socket, $opt) = @_;

   # unblock socket when reading
   $socket->blocking(0);
   
   print get_timestamp(), "waiting information from remote ...\n";

   my $captures = expect_socket($socket,
                      [ '<PATH>(.+)</PATH>',
                        '<TREE>(.*)</TREE>',
                        '<MAXSIZE>([-]?\d+)</MAXSIZE>',
                        '<VERSION>(.+)</VERSION>',
                        '<EXCLUDE>(.*)</EXCLUDE>',
                        '<MATCH>(.*)</MATCH>',
                        '<DEEP>(.)</DEEP>',
                        '<UNAME>(.+)</UNAME>',
                      ],
                      {  verbose=>$verbose, 
                         ExpectTimeout=>$timeout,
                         #dropped <VERSION> as it is seen in port scanners
                         #BeginPattern=>'<(VERSION|UNAME|PATH)>',
                         BeginPattern=>'<(UNAME|PATH)>',
                      }
                     );

   if (!$captures) {
      $bad_format_count ++;
      print "ERROR: received bad format $bad_format_count times\n";

      if ($bad_format_count >= 3) {
         print "FATAL: likely being under attack. we exit\n";
         exit 1;
      }

      $socket->close();
      return;
   } else {
      $bad_format_count = 0;
   }

   my $local_paths_string  = $captures->[0]->[0];
   my $remote_tree_block   = $captures->[1]->[0];
   my $maxsize             = $captures->[2]->[0];
   my $version             = $captures->[3]->[0];
   my $exclude_string      = $captures->[4]->[0];
   my $match_string        = $captures->[5]->[0];
   my $deep_check          = $captures->[6]->[0];
   my $uname               = $captures->[7]->[0];

   my ($peer_protocol) = ($version =~ /^(\d+)/);

   if ($peer_protocol != $expected_peer_protocol) {
      my $message = "wrong protocol $peer_protocol. expecting protocol $expected_peer_protocol(.*). closed the connection.\n";
      print get_timestamp(), "$message\n";
      socket_send($socket, "$message\n");
      $socket->close();
      return;
   }

   # we only check modes between compatible platforms
   my $check_mode = ($uname !~ /Windows/i ) ? 1 : 0;

   print get_timestamp(), "remote uname='$uname'. we set check_mode=$check_mode\n";

   print get_timestamp(), "remote used matched protocol $peer_protocol\n";

   my @excludes;
   if ($exclude_string) {
      @excludes = split /\n/, $exclude_string;
   }

   my @matches;
   if ($match_string) {
      @matches = split /\n/, $match_string;
   }
   
   my $remote_tree;

   if ($remote_tree_block) {
      my @lines = split /\n/, $remote_tree_block;

      for my $l (@lines) {
         next if !$l || $l !~ /^key=/;

         my $r;

         for my $pair (split /[|]/, $l) {
            my ($k, $v) = ($pair =~ /^(.+?)=(.+)/);
            $r->{$k} = $v;
         }

         $remote_tree->{$r->{key}} = $r;
      }
   }

   print get_timestamp(), "building local_tree using paths: $local_paths_string\n";
   print get_timestamp(), "relative path base is homedir=$homedir\n";

   my @local_paths = split (/[|]/, $local_paths_string);

   # on to_be_pulled side, we need check access with AllowDenyPatterns.
   # matches and excludes are coming from remote side
   # RelativeBase is coming from command line
   my $local_tree = build_dir_tree(\@local_paths,
                                              {verbose=>$verbose,
                                               RelativeBase=>$homedir,
                                               AllowDenyPatterns=>$opt->{AllowDenyPatterns},
                                               excludes=>\@excludes,
                                               matches=>\@matches,
                                              }
                                             );

   $verbose && print "remote_tree = ", Dumper($remote_tree);
   $verbose && print "local_tree = ",  Dumper($local_tree);
   $verbose && print "maxsize = $maxsize\n";

   my @deletes;
   my $change_by_file; # this includes both add and update
   my $diff_by_file; # files are diff'able, only when type=file.
   my @modes;
   my @warns;
   my $RequiredSpace = 0;
   my $need_mtime_reset;
   my @need_cksums;

   # compare local_tree with remote_tree
   if ($remote_tree) {
      for my $k (sort (keys %$remote_tree)) {
         if (!$local_tree->{$k}) {
            # if the back dir is not shown in local side at all, don't delete it on
            # remote side.
            # for example, assume remote side runs command as
            #    $0 client host port a b
            # if 'a' doesn't exist on the local side, we (local side) should not tell
            # remote to delete b/a on the remote side
          
            my $back = $remote_tree->{$k}->{back};
   
            if ($local_tree->{$back}) {
               push @deletes, $k;
            }
         }
      }
   }

   # we sort reverse so that files come before their parent dir. This way enables
   # us to copy some (not have to be all) files under a dir
   for my $k (reverse (sort (keys %$local_tree))) {
      my ( $local_size,  $local_type,  $local_test,  $local_mtime,  $local_mode) = @{ $local_tree->{$k}}{qw(
                  size          type          test          mtime          mode )};

      my $skipped_message = $local_tree->{$k}->{skip};
      if ($skipped_message) {
         # note: we only skip to copy this file to remote side
         # not to tell the remote side to delete this file: not to add it to @deletes.
         push @warns, "skipped $k: $skipped_message";
         next;
      }

      if (!exists $remote_tree->{$k} || $remote_tree->{$k}->{type} ne $local_type) {
         # remote missing this file or remote is a different type of file: eg, file vs directory

         if ($local_size) {
            if ($maxsize >=0 && $RequiredSpace+$local_size > $maxsize) {
               print get_timestamp(), "size cutoff before $k: RequiredSpace+local_size($RequiredSpace+$local_size) > maxsize($maxsize)\n";
               last;
            }
            $RequiredSpace += $local_size;
         }

         if (exists $remote_tree->{$k}) {
            # if remote file exists, it must be of a different type, remove it first and then add
            $change_by_file->{$k} = "newType";
            push @deletes, $k;
         } else {
            $change_by_file->{$k} = "add";
         } 

         if ($local_type eq 'dir') {
            # We don't tar dir because that would tar up all files under dir.
            # But the problem with this approach is that the dir mode
            # (permission) is then not recorded in the tar file. We will have
            # to keep and send the mode information separately (from the tar file).
            # so is the mtime.
            if ($check_mode) {
               push @modes, $k;
            }   
            $need_mtime_reset->{$k} = 1;
         }
         next;
      }

      # do this only after we knew the key exists in $remote_tree. otherwise, autovivification will insert the key
      my ($remote_size, $remote_type, $remote_test, $remote_mtime, $remote_mode) = @{$remote_tree->{$k}}{qw(
                  size          type          test          mtime          mode )};

      # now that both sides are same kind type: file, dir, or link
      if ( $check_mode && $local_type ne 'link' && $remote_mode != $local_mode ) {
         push @modes, $k;
      }

      # note: dir and link's sizes are hard-coded, so they will always equal.
      # therefore, we are really only compares file's sizes.
      # that is, only files can have different sizes.
      if ( $remote_size != $local_size ) {
         # only files can reach here
         if ($local_size) {
            if ($maxsize >=0 && $RequiredSpace+$local_size > $maxsize) {
               print get_timestamp(), "size cutoff before $k: RequiredSpace+local_size($RequiredSpace+$local_size) > maxsize($maxsize)\n";
               last;
            }
            $RequiredSpace += $local_size;
         }

         $change_by_file->{$k} = "update";
         $diff_by_file->{$k} ++; # files are diff'able

         next;
      }

      # compare {test} if it is populated
      # because dir's {test} and link's {test} are hardcoded, we are really only compare files, 
      if (!$local_test && !$remote_test) {
         # if both missing tests, we compare mtime first
         # for fast check (default), if size and mtime match, then no need to update.
         # for deep check, or when mtime not matching (but size matching), resort to
         # cksum.

         if ($remote_mtime != $local_mtime) {
            push @need_cksums, $k;
            $need_mtime_reset->{$k} = 1
         } elsif ($deep_check) {
            # $remote_mtime == $local_mtime is true
            push @need_cksums, $k;
         }
      } elsif ( !$local_test || !$remote_test) {
         # we reach here if only one test is missing.
         # note: if both tests are missing, the previous logic would have already taken care of it.
         # not sure what situation will lead us here yet
       
         $change_by_file->{$k} = "update";
      } elsif ($local_test ne $remote_test) {
         # now both tests exist, we can safely compare
         # not sure what situation will lead us here yet

         $change_by_file->{$k} = "update";
      } else {
         # $local_test eq $remote_test
         if ($remote_mtime != $local_mtime) {
            $need_mtime_reset->{$k} = 1
         }
      }
   }

   # instead, flush writes manually 
   $socket->blocking(1);

   my $need_cksums_string = "<NEED_CKSUMS>" . join("\n", @need_cksums) . "</NEED_CKSUMS>";
   print get_timestamp(), "sending need_cksums request to remote: ", scalar(@need_cksums), " items.\n";
   $verbose && print "   $need_cksums_string\n";
   socket_send($socket, "$need_cksums_string\n");

   $socket->flush(); # flush data when writes are done.
  
   print get_timestamp(), "collecting local cksums: ", scalar(@need_cksums), " items.\n";
   my $local_cksum_by_file = get_cksums(\@need_cksums, $local_tree, {verbose=>$verbose});

   # unblock socket when reading
   $socket->blocking(0);

   print get_timestamp(), "waiting remote cksum results.\n";

   $captures = expect_socket($socket,
                         [ '<CKSUM_RESULTS>(.*)</CKSUM_RESULTS>',
                         ],
                         {verbose=>$verbose, ExpectTimeout=>$timeout}
                    );
   if (!$captures) {
      $socket->close();
      return;
   }

   my $remote_cksums_string = $captures->[0]->[0];

   my $remote_cksum_by_file;
   if ($remote_cksums_string) {
      for my $row (split /\n/, $remote_cksums_string) {
         if ($row =~ /^(\d+) (.+)$/) {
            $remote_cksum_by_file->{$2} = $1;
         }
      }
   }

   for my $f (keys %$local_cksum_by_file) {
      if ( !$remote_cksum_by_file->{$f} ) {
         print "ERROR: remote cksum results missing for $f\n";
         $change_by_file->{$f} = "update";
      } elsif ($remote_cksum_by_file->{$f} ne $local_cksum_by_file->{$f} ) {
         $change_by_file->{$f} = "update";
         $diff_by_file->{$f}++; # only type=file can get here.
      } elsif ($remote_tree->{$f}->{mtime} != $local_tree->{$f}->{mtime}) { 
         $need_mtime_reset->{$f} = 1
      }
   }

   for my $k (@deletes, keys(%$change_by_file)) {
      # when we untar to update a file, the file's parent dir's timestamp is updated. we need
      # to restore the timestamp
      if ($k =~ m:^(.+)/:) {
         my $parent_dir = $1;
         if (exists $local_tree->{$parent_dir}) {
            # parent_dir may be filtered out by match/exclude patterns, therefore, we need to
            # check its existence
            $need_mtime_reset->{$parent_dir} = 1;
         }   
      }
   }

   my @mtimes;
   for my $f (keys %$need_mtime_reset) {
      push @mtimes, $f if $local_tree->{$f};
   }

   # don't unblock socket when writing; doing so would corrupt data.
   # instead, flush writes manually
   $socket->blocking(1);

   my $delete_string = "<DELETES>" . join("\n", sort(@deletes)) . "</DELETES>";
   print get_timestamp(), "sending deletes: ", scalar(@deletes), " item(s)\n";
   $verbose && print "   $delete_string\n";
   socket_send($socket, "$delete_string\n");

   my $adds_string = "<ADDS>";
   my @adds_files = sort (keys %$change_by_file);

   for my $f (@adds_files) {
      my $action = $change_by_file->{$f};
      $adds_string .= sprintf("\%6s \%s\n", $action, $f);
   }
   # $adds_string =~ s:\n$::; # remove the last newline

   $adds_string .= "</ADDS>";
   print get_timestamp(), "sending adds: ", scalar(@adds_files), " item(s)\n"; 
   $verbose && print "   $adds_string\n";
   socket_send($socket, "$adds_string\n");

   my $mtime_string = "<MTIMES>";
   for my $f (@mtimes) {
      my $mt = $local_tree->{$f}->{mtime}; 
      $mtime_string .= "$mt $f\n";
   }
   $mtime_string .= "</MTIMES>";

   print get_timestamp(), "sending mtimes: ", scalar(@mtimes), " item(s)\n"; 
   $verbose && print "   $mtime_string\n";
   socket_send($socket, "$mtime_string\n");

   my $mode_string = "<MODES>";
   if ($check_mode) {
      for my $f (@modes) {
         my $mode = $local_tree->{$f}->{mode};
         $mode_string .= "$mode $f\n";
      }
      print get_timestamp(), "sending modes: ", scalar(@modes), " item(s)\n";
   } else {
      print get_timestamp(), "sending modes: 0 item(s) as we don't check modes\n";
   }
   $mode_string .= "</MODES>";
   $verbose && print "   $mode_string\n";
   socket_send($socket, "$mode_string\n");

   my $warn_string = "<WARNS>" . join("\n", @warns) . "</WARNS>";
   print get_timestamp(), "sending warns: ", scalar(@warns), " item(s)\n";
   print "   ", join("\n   ", @warns), "\n";
   $verbose && print "   $warn_string\n";
   socket_send($socket, "$warn_string\n");

   print get_timestamp(), "sending required space: $RequiredSpace\n";
   $verbose && print "   <SPACE>$RequiredSpace</SPACE>\n";
   socket_send($socket, "<SPACE>$RequiredSpace</SPACE>\n");

   $socket->flush(); # flush data when writes are done.

   if (!$change_by_file) {
      print get_timestamp(), "remote doesn't need to add/update any new files\n";
      return;
   }

   # unblock socket when reading
   $socket->blocking(0);

   print get_timestamp(), "waiting for transfer mode from remote\n";

   $captures = expect_socket(
              $socket,
              ["please send (data|diff)"],
              {verbose=>$verbose, ExpectTimeout=>$timeout}
           );

   if (!$captures) {
      $socket->close();
      return;
   }

   my $mode = $captures->[0]->[0];

   print get_timestamp(), "received remote tranfer mode: $mode. creating tmp local tar file\n";

   my $tmp_tar_file = get_tmp_file($tmpdir, "$prog.tar",  {chkSpace=>$RequiredSpace*2});
   my $tmp_tar_list = get_tmp_file($tmpdir, "$prog.list");

   croak "cannot get a tmp file under $tmpdir. disk full?" if !$tmp_tar_file;

   my $files_to_tar;
   if ($mode eq 'diff') {
      @{$files_to_tar} = sort (keys %$diff_by_file);
   } else {
      $files_to_tar = \@adds_files;
   }

   if (!@{$files_to_tar}) {
      print get_timestamp(), "no need to send anything to remote\n";
      return;
   }

   my $files_by_front;

   for my $f (@$files_to_tar) {
      if ($local_tree->{$f}->{type} eq 'dir' && !$local_tree->{$f}->{DirEmpty} ) {
         # Skip non-empty dir because tar'ing dir will also tar the files underneath.
         # But we include empty dir
         $verbose && print "Skipped dir $f because we will add files under it anyway\n";
          next;
      }

      my $front = $local_tree->{$f}->{front};
      push @{$files_by_front->{$front}}, $f;
   }

   my $created_tar;

   for my $front (sort(keys %$files_by_front)) {
      my @files = sort @{$files_by_front->{$front}};

      next if !@files;

      #my $file_string = '';
      open my $list_fh, ">$tmp_tar_list" or croak "cannot write to $tmp_tar_list: $!";

      for my $f (@files) {
         next if ! defined $f;

         # use '' to wrap file name in case there are space chars.
         print {$list_fh} "$f\n";
      }

      close $list_fh;

      tar_file_list($front, $tmp_tar_file, $created_tar, $tmp_tar_list);
      $created_tar ++;
   }

   if ( !$created_tar ) {
      print get_timestamp(), "no tar created, close this remote connection.\n";
      return;
   }

   # don't unblock socket when writing; doing so would corrupt data.
   # instead, flush writes manually
   $socket->blocking(1);

   print get_timestamp(), "sending tar-format data (mode=$mode) to remote.\n";

   open my $fh, "< $tmp_tar_file" or die "cannot read $tmp_tar_file"; 
   binmode($fh);

   my $tar_size = 0;

   while(1) {
      my $data;

      my $size = read($fh, $data, 1024000);

      last if !$size;

      socket_send($socket, $data);

      $tar_size += $size;
   }

   close $fh;

   $socket->close();

   print get_timestamp(), "sent tar_size=$tar_size. closed remote connection\n";

   if ($KeepTmpFile) {
      print get_timestamp(), "tmp file $tmp_tar_file is kept\n";
   } else {
      unlink($tmp_tar_file);
      unlink($tmp_tar_list);
   }
}

sub to_pull {
   my ($socket, $remote_paths, $local_dir, $opt) = @_;

   # http://www.perlmonks.org/?node_id=304388
   
   $| = 1;

   my $dryrun_string = "";
   if ($dryrun||$diff) {
      $dryrun_string = "dryrun";
   }

   $local_dir =~ s:[/]+$::; # remove the trailing /
   my $local_dir_abs = get_abs_path($local_dir);

   my @local_paths;
   for my $remote_path (@$remote_paths) {
      if ($remote_path =~ m!$root_dir_pattern!) {
         my $message = "cannot copy root dir $remote_path";
         print "ERROR: $message\n";
         socket_send($socket, "$message\n");
         return;
      }   

      $remote_path =~ s:[/]+$::g;       # remove the trailing /

      # get the last component; we will treat it as a subdir right under local_dir
      my ($back) = ( $remote_path =~ m:([^/]+)$: );

      my $local_path = "$local_dir/$back";

      # resolve dir/*csv to dir/a.csv, a/b.csv, ...
      #    example:
      #       $0 client host port /a/b/c/*.csv d
      #    we need to check whether we have d/*.csv
    
      my @globs = `/bin/ls -1d $local_path 2>/dev/null`;
      next if !@globs;

      chomp @globs;

      for my $path (@globs) {
         my $local_abs = get_abs_path("$path");

         next if !$local_abs;

         $verbose && print get_timestamp(), "remote ($remote_path) -> local ($local_path) -> local abs ($local_abs)\n";

         push @local_paths, $local_abs;
      }
   }

   $quiet || print get_timestamp(), "building local tree using abs_path: ", join(" ", @local_paths), "\n";

   # on to_pull side, we don't check access with AllowDenyPatterns.
   # matches and excludes are coming from command line
   my $local_tree = build_dir_tree(\@local_paths, {verbose=>$verbose,
                                           excludes=>\@excludes,
                                           matches=>\@matches,
                                          });
   $verbose && print "local_tree = ", Dumper($local_tree);

   # don't unblock socket when writing; doing so would corrupt data.
   # instead, flush writes manually
   $socket->blocking(1);

   my $version_string = "<VERSION>$version</VERSION>";
   $quiet || print get_timestamp(), "sending version: $version\n";
   $verbose && print "   $version_string\n";
   socket_send($socket, "$version_string\n");

   my $uname = `uname -a`; chomp $uname;
   $uname = "Perl|$uname";
   my $uname_string = "<UNAME>$uname</UNAME>";
   $quiet || print get_timestamp(), "sending prog|uname: $uname\n";
   $verbose && print "   $uname_string\n";
   socket_send($socket, "$uname_string\n");

   my $paths_string = join("|", @$remote_paths);
   $quiet || print get_timestamp(), "sending paths: $paths_string\n";
   $paths_string = "<PATH>$paths_string</PATH>";
   $verbose && print "   $paths_string\n";
   socket_send($socket, "$paths_string\n");

   $quiet || print get_timestamp(), "sending deep check flag: $deep\n";
   my $deep_string = "<DEEP>$deep</DEEP>";
   $verbose && print "   $deep_string\n";
   socket_send($socket, "$deep_string\n");

   my $local_tree_block = "";
   my $local_tree_items = 0;

   my $skipped = 0;
   if ($local_tree) {
      for my $k (sort keys(%$local_tree)) {
         my $skip_message = $local_tree->{$k}->{skip};
         if ($skip_message) {
            # don't send skipped file to remote; this way, remote will not 
            # tell us to delete them.
            $skipped ++;
            next;
         }
         $local_tree_items ++;
         my $string = "key=$k";
         for my $attr (sort (keys %{$local_tree->{$k}})) {
            $string .= "|$attr=$local_tree->{$k}->{$attr}";
         }
         $local_tree_block .= "$string\n";
      }
   }

   $quiet || print get_timestamp(), "sending local_tree, $local_tree_items items, skipped $skipped\n";
   $verbose && print "   <TREE>$local_tree_block</TREE>\n";
   socket_send($socket, "<TREE>$local_tree_block</TREE>\n");

   $quiet || print get_timestamp(), "sending maxsize: $maxsize\n";
   my $maxsize_string = "<MAXSIZE>$maxsize</MAXSIZE>";
   $verbose && print "   $maxsize_string\n";
   socket_send($socket, "$maxsize_string\n");

   my $excludes_string = "";
   if (@excludes) {
      $excludes_string = join("\n", @excludes);
   }
   $quiet || print get_timestamp(), "sending excludes: $excludes_string\n";
   $excludes_string = "<EXCLUDE>$excludes_string</EXCLUDE>";
   $verbose && print "   $excludes_string\n";
   socket_send($socket, "$excludes_string\n");

   my $matches_string = "";
   if (@matches) {
      $matches_string = join("\n", @matches);
   }
   $quiet || print get_timestamp(), "sending matches: $matches_string\n";
   $matches_string="<MATCH>$matches_string</MATCH>";
   $verbose && print "   $matches_string\n";
   socket_send($socket, "$matches_string\n");

   $socket->flush(); # flush data when writes are done.

   # unblock socket when reading
   $socket->blocking(0);

   $quiet || print get_timestamp(), "waiting cksum requests from remote...\n";

   my $captures = expect_socket(
              $socket,
              [ '<NEED_CKSUMS>(.*)</NEED_CKSUMS>',],
              {verbose=>$verbose, ExpectTimeout=>$timeout}
           );

   if (!$captures) {
      $socket->close();
      return;
   }

   my $need_cksums_string = $captures->[0]->[0];

   my @need_cksums;
   my @cksums_results;
   if ($need_cksums_string) {
      @need_cksums = split /\n/, $need_cksums_string;
      $quiet|| print get_timestamp(), "received cksum requests, ", scalar(@need_cksums), " items. calculating local cksums\n";

      my $local_cksums_by_file = get_cksums(\@need_cksums, $local_tree);

      for my $f (sort (keys %$local_cksums_by_file)) {
         push @cksums_results, "$local_cksums_by_file->{$f} $f";
      }
   } else {
      $quiet || print get_timestamp(), "received cksum requests, 0 items\n";
   }

   # don't unblock socket when writing; doing so would corrupt data.
   # instead, flush writes manually
   $socket->blocking(1);

   my $cksums_results_string = join("\n", @cksums_results);
   $cksums_results_string = "<CKSUM_RESULTS>$cksums_results_string</CKSUM_RESULTS>";

   $quiet || print get_timestamp(), "sending cksum results: ", scalar(@cksums_results), " item(s)\n";
   $verbose  && print  "   $cksums_results_string\n";
   socket_send($socket, "$cksums_results_string\n");

   $socket->flush(); # flush data when writes are done.

   $quiet || print get_timestamp(), "waiting instructions from remote ...\n";

   # unblock socket when reading
   $socket->blocking(0);

   $captures = expect_socket(
              $socket,
              [ '<DELETES>(.*)</DELETES>',
                '<MTIMES>(.*)</MTIMES>',
                '<MODES>(.*)</MODES>',
                '<SPACE>(\d+)</SPACE>',
                '<ADDS>(.*)</ADDS>', 
                '<WARNS>(.*)</WARNS>',
              ],
              {verbose=>$verbose, ExpectTimeout=>$timeout}
           );

   if (!$captures) {
      $socket->close();
      return;
   }

   my $deletes_string = $captures->[0]->[0];
   my $mtimes_string  = $captures->[1]->[0];
   my $modes_string   = $captures->[2]->[0];
   my $RequiredSpace  = $captures->[3]->[0];
   my $adds_string    = $captures->[4]->[0];
   my $warns_string   = $captures->[5]->[0];
    
   # if local_dir doesn't exist yet, we don't mkdir now because if this is a
   # dryrun or diff, then we shouldn't create a dir. we will create it later.
   # But why do we "cd $local_dir_abs" here? because the followed deletes use
   # the relative path; so does diff.
   if (-d $local_dir_abs) {
      $quiet || print get_timestamp(), "cd '$local_dir_abs'\n";
      chdir($local_dir_abs) || croak "cd '$local_dir_abs' failed";

      if ($deletes_string) {
         my @deletes = split /\n/, $deletes_string;
   
         my $last_delete;
   
         for my $d (sort @deletes) {
            if (!$last_delete || $d !~ m:^$last_delete/: ) {
               # if we already deleted the dir, no need to delete files under it.
   
               my $cmd = "/bin/rm -fr '$d'";
               if ($dryrun||$diff) {
                  print "dryrun $cmd\n";
               } else {
                  print "$cmd\n";
                  system($cmd);
                }  
   
               $last_delete = $d;
            }
         }
      }
   }

   my @diff_files;

   if ($adds_string) {
      my $action_by_file;

      my @adds = split /\n/, $adds_string;
      for my $a (@adds) {
         next if !$a;
         if ($a =~ /^\s*(\S+?) (.+)/) {
            my $action = $1;
            my $file = $2;

            push @diff_files, $file if $action eq 'update';

            if ($action_by_file->{$file}) {
               print STDERR "ERROR: $file appeared more than once on remote side\n";
            }
            $action_by_file->{$file} = $action;
         } else {
            croak "unexpected format $a. expecting: (add|update|newType) file";
         }
      }

      for my $f (sort (keys %$action_by_file)) {
         printf "$dryrun_string %7s %s\n", $action_by_file->{$f}, $f;
      }
   }

   my @warns = split /\n/, $warns_string;
   for my $w (@warns) {
      print "warning from remote side: $w\n";
   }

   # check tmp space
   my $tmp_tar_file = get_tmp_file($tmpdir, $prog, {chkSpace=>$RequiredSpace*2});

   if (!$tmp_tar_file) {
      $quiet || print get_timestamp(), "space check: not enough space under $tmpdir, requiring ", $RequiredSpace*2, " bytes, disk full?\n";
      exit 1 if !$dryrun;
   } else {
      $quiet || print get_timestamp(), "space check: enough space under $tmpdir, requiring ", $RequiredSpace*2, " bytes.\n";
   }

   if (!$adds_string) {
      my $message = "nothing to add or update\n";
      $quiet || print get_timestamp(), $message;
      socket_send($socket, $message);
   } elsif (!$dryrun) {
      # don't unblock socket when writing; doing so would corrupt data.
      # instead, flush writes manually
      $socket->blocking(1);

      if ($diff) {
         socket_send($socket, "please send diff\n");
      } else {
         socket_send($socket, "please send data\n");
      }
   
      $socket->flush();
   
      my $tmp_diff_dir;
      if ($diff) {
         $tmp_diff_dir = get_tmp_file($tmpdir, $prog, {isDir=>'Y', chkSpace=>$RequiredSpace*2});
         if (! -d $tmp_diff_dir) {
            my $cmd = "mkdir -p '$tmp_diff_dir'";
            $quiet || print get_timestamp(), "$dryrun_string $cmd\n";
            $dryrun || system($cmd) && croak "$cmd failed";
         }
   
         print get_timestamp(), "cd '$tmp_diff_dir'\n";
         chdir($tmp_diff_dir) || croak "cd '$tmp_diff_dir' failed";
      } else {
         if (! -d $local_dir_abs) {
            my $cmd = "mkdir -p '$local_dir_abs'";
            $quiet || print get_timestamp(), "$dryrun_string $cmd\n";
            $dryrun || system($cmd) && croak "$cmd failed";
         }
   
         $quiet || print get_timestamp(), "cd '$local_dir_abs'\n";
         chdir($local_dir_abs) || croak "cd '$local_dir_abs' failed";
      }
   
      # unblock socket when reading
      $socket->blocking(0);
   
      $quiet || print get_timestamp(), "waiting for data from remote\n";
      my $select = IO::Select->new($socket) or die "IO::Select $!";
   
      my $tar_size = 0;
      my $total_data;
   
      my $fh;
   
      while(1) {
         next if !$select->can_read(300);
   
         my $data;
   
         my $size = read($socket, $data, 2048000);
         if (!$size) {
            $verbose && print get_timestamp(), "remote closed connection\n";
             last;
         } else {
            if (!$fh) {
               # Open this fh only when we really have data.
               # This doesn't work because the binmode() only works on file not on a command pipe
               # open $fh, "|tar -xvfp -" or die "tar -xvfp - failed";
               # Therefore, we save the output to file.
               #
               open $fh, ">$tmp_tar_file" or die "cannot write to $tmp_tar_file";
               binmode($fh);
            }

            $tar_size += $size;
            print {$fh} xor_encode($data, 'in');
         }
      }

      close $fh if $fh;
      $socket->close();

      $quiet || print get_timestamp(), "received tar_size = $tar_size\n" if $verbose;

      if ($tar_size == 0) {
         $quiet || print get_timestamp(), "no new file to add\n";
      } else {
         my $tar_verbose = $quiet ? "" : "v";

         my $cmd = ($os_name =~ /^CYGWIN|Msys/i) ? "tar -x${tar_verbose}f  $tmp_tar_file" :
                                                   "tar -x${tar_verbose}pf $tmp_tar_file";
         #Msys is Git Bash 
         print get_timestamp(), "$cmd\n" if $verbose;
         system($cmd);
      }

      if ($KeepTmpFile) {
         print get_timestamp(), "tmp_gar_file $tmp_tar_file is kept\n";
      } else {
         print get_timestamp(), "rm tmp_tar_file $tmp_tar_file\n";
         unlink($tmp_tar_file);
      }

      if ($diff) {
         $verbose && print get_timestamp(), "cd '$old_pwd'\n";
         chdir($old_pwd) || croak "cannot cd '$old_pwd'";

         for my $relative_path (@diff_files) {
            my $cmd = "diff '$tmp_diff_dir/$relative_path' '$local_dir_abs/$relative_path'";
            print "$cmd\n";
            system($cmd);
            print "\n";
         }

         if ($KeepTmpFile) {
            print get_timestamp(), "tmp_diff_dir '$tmp_diff_dir' is kept\n";
         } else {
            my $cmd = "/bin/rm -fr '$tmp_diff_dir'";
            print get_timestamp(), "rm tmp_diff_dir: $cmd\n";
            system($cmd);
         }
      }
   }

   if ($mtimes_string) {
      my @lines = split /\n/, $mtimes_string;

      for my $l (@lines) {
         if ($l =~ /^([0-9]+)\s+(\S.*)/) {
            my ($mtime, $f) = ($1, $2);
            print "$dryrun_string utime($mtime, $mtime, $f)\n";
            if ( !$dryrun && !$diff) {
               utime($mtime, $mtime, $f) || print "utime($mtime, $mtime, $f) failed\n";
            }
         } else {
            print "bad mtime format at line: $l\n";
         }
      }
   }

   if ($modes_string) {
      my @lines = split /\n/, $modes_string;
      
      for my $l (@lines) {
         if ($l =~ /^([0-9]+)\s+(\S.*)/) {
            my ($mode, $f) = ($1, $2);
   
            #my $octal = sprintf("0%o", $mode);
            print "$dryrun_string chmod(oct(\"$mode\"), $f)\n";

            if (!$dryrun && !$diff) {
               chmod(oct("$mode"), $f);
            }
         } else {
            print "bad mode format at line: $l\n";
         }
      }
   }
}

sub socket_send {
   my ($socket, $plain_str) = @_;

   $socket->send(xor_encode($plain_str, 'out'));

   my $size = length($plain_str);
   $out_count += $size;
   $verbose && print "   sent $size bytes, total=$out_count\n";
}

sub xor_encode {
   my ($plain_str, $tag) = @_;

   return $plain_str if !$encrypt_key;

   my $encrypted_str = '';
   my $key_index = $key_index_by_tag->{$tag};


   for my $char (split //, $plain_str){
      $encrypted_str .= chr(ord($char) ^ ord($key_array[$key_index]));

      $key_index ++;
      if ($key_index == $key_length) {
         $key_index = 0;
      }   
    }

    $key_index_by_tag->{$tag} = $key_index;
    return $encrypted_str;
}

###################################################################################
# BEGIN logic copied from .../site_perl/String/CRC/Cksum.pm
use integer; # for cksum
sub get_cksums {
   my ($files, $dir_tree, $opt) = @_;
   my $cksum_by_file;

   for my $f (@$files) {
      my $front = $dir_tree->{$f}->{front};
      if (!$front) {
         print STDERR "missing \$dir_tree->{$f}->{front}. skipped\n";
         next;
      }
      $opt->{verbose} && print get_timestamp(), "calculating cksum('$front/$f')\n";
      $cksum_by_file->{$f} = cksum("$front/$f");
   }
   return $cksum_by_file;
}

sub cksum {
   my ($file, $opt) = @_;

   my $cksum = 0;
   my $size = 0;

   open my $ifd, "<$file";

   if (!$ifd) {
      carp "cannot read $file";
      return 0;
   }

   while(1) {
      my $data;
      my $n = read($ifd, $data, 4096);

      if (! defined $n) {
         croak "error reading from $file: $!";
      }

      last if !$data;

      $size += $n;

      #for (my $i = 0; $i < $n; ++$i) {
      # my $c = unpack 'C', substr $data, $i, 1;
      # $cksum = (0xFFFFFFFF & ($cksum << 8)) ^ $crctab[(0xFF & ($cksum >> 24)) ^ $c]; #}
      
      # C - an unsigned char
      # If the input string is longer than needed, extra characters are ignored.
      # A * for the repeat count uses all characters of the input field. For unpack, nybbles
      # are converted to a string of hexadecimal digits.
      for my $c (unpack 'C*', $data) {
         #$cksum = (0xFFFFFFFF & ($cksum << 8)) ^ $crctab[(0xFF & ($cksum >> 24)) ^ $c];
         # break this into steps for easier troubleshooting.
	 my $index = (0xFF & ($cksum >> 24)) ^ $c;
	 $cksum = (0xFFFFFFFF & ($cksum << 8)) ^ $crctab[$index];
      }
   }

   close $ifd;

   # Extend with the length of the data
   while($size != 0) {
      my $c = $size & 0xFF;
      $size >>= 8;
      $cksum = (0xFFFFFFFF & ($cksum << 8)) ^ $crctab[(0xFF & ($cksum >> 24)) ^ $c];
   }

   $cksum = ~ $cksum;
   # ~ is bitwise negation operator
   # $ perl -e 'printf("%b\n",   1);'
   # 1
   # $ perl -e 'printf("%b\n",  ~1);'
   # 1111111111111111111111111111111111111111111111111111111111111110

   # positivise the result even on a 32 bit processor
   # perl -e 'printf("%ld\n", 1024*1024*1024*4);'
   # 4294967296
   # this is 2e32
   no integer;
   my $crc = $cksum;
   $crc += 4294967296 if $crc < 0;

   return $crc;
}

# In $cygwin/perl, when (-r $f) failed, the file may still be readable.
# This is because cygwin/perl only checks the standard UNIX bits
#    drwxrwxrwx
# Windows file may also have extended ACL, as indicated by the "+" at
# the end.
#
#    $ ls -ld /cygdrive/c/Windows/notepad.exe
#    -rwxr-x---+ 3 NT SERVICE+TrustedInstaller NT SERVICE+TrustedInstaller 181248 Mar 11 17:07 
#                                                                             /cygdrive/c/Windows/notepad.exe
#
# test '-r $file'
#    $ perl -e '! -r "/cygdrive/c/Windows/notepad.exe" && print "test read failed\n"'
#    test read failed
#
# getfacl can show more ACL permissions
#    $ getfacl /cygdrive/c/Windows/notepad.exe
#    file: /cygdrive/c/Windows/notepad.exe
#    owner: NT SERVICE+TrustedInstaller
#    group: NT SERVICE+TrustedInstaller
#    user::rwx
#    group::---
#    group:SYSTEM:r-x
#    group:Administrators:r-x
#    group:Users:r-x
#    group:ALL APPLICATION PACKAGES:r-x
#    group:ALL RESTRICTED APPLICATION PACKAGES:r-x
#    mask::r-x
#    other::---
#    
# we can read the file with 'head'
#    $ head -n 1 /cygdrive/c/Windows/notepad.exe
#    ...
#
# cygwin/perl can open the file in read mode too.
#    $ perl -e 'open my $fh, "</cygdrive/c/Windows/notepad.exe" and print "can read\n"'
#    can read
#
# there seems no good getfacl module in cygwin/perl, therefore, we resort to the following open-file test.
#
# GitBash/Perl doesn't have this problem.
#   $ ls -ld /c/Windows/notepad.exe
#   -rwxr-xr-x 3 william 197121 181248 Mar 11 17:07 /c/Windows/notepad.exe

sub test_read_by_open {
   my ($file, $opt) = @_;
   open my $fh, "<$file" or return 0;
   close $fh;
   return 1;
}


# END
###################################################################################

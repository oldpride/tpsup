#!/bin/bash


prog=`basename $0`
user=`id |cut -d\( -f2|cut -d\) -f1`

putty_client_file=~/.tpsup/putty_client.txt

min=0
max=9

usage () {
   cat >&2 <<EOF
usage:

   $prog auto
   $prog min max

   position a putty's window in the next available position between min and max.

   min starts from 0.
   max should not be greater than min+10. This limit is set by putty doesn't spawn
   more than 10 windows in the same session.

   'auto' means to get min and max from $putty_client_file.

   if no available position, quit; the putty window will not be moved.

   This script works both in initial login and in login-then-su cases.

examples:

   $prog auto
   $prog 0 9
   $prog 10 12

EOF
   exit 1
}


verbose=N
flag=""
while getopts v o;
do
   case "$o" in
      v)  verbose=Y;flag=-v;;
      #x)  max=$OPTARG;;
      *)   usage;;
   esac
done

shift $((OPTIND-1))

if [ $# -ne 1 -a $# -ne 2 ]; then
   echo "wrong number of args" >&2
   usage
fi

# $ env |grep SSH
# SSH_CONNECTION=192.168.1.62 50334 192.168.1.191 22
# SSH_CLIENT=192.168.1.62 50334 22
# SSH_TTY=/dev/pts/4

# putty_ip=$(echo $SSH_CLIENT | cut -d" " -f1)
# It is possible that SSH_CLIENT is not set, for example, when we "su - appid".
# In Linux 5.15, "su -w SSH_CLIENT - appid" will pass the SSH_CLIENT to the new shell.
# But for older Linux, this is not supported.
# if SSH_CLIENT is not set, then we use 'who/tpwho' comand to get the putty client IP

WHO=$(tpwho current)
if [ $verbose = Y ]; then
   echo "WHO=$WHO"
fi

putty_login=$(echo $WHO | awk '{print $1}')
putty_tty=$(echo $WHO | awk '{print $2}')
putty_ip=$(echo $WHO | awk '{print $3}')
putty_pid=$(ps -t $putty_tty --sort=start_time |grep bash |head -n 1|awk '{print $1}')

if [ $verbose = Y ]; then
   echo "putty_login=$putty_login"
   echo "putty_tty=$putty_tty"
   echo "putty_ip=$putty_ip"
fi

if [ "X$putty_ip" = "X" ]; then
   [ $verbose = Y ] && echo "ERROR: cannot get putty client IP from 'who' command." >&2
   exit 1
fi

if [ "$1" = "auto" ]; then
   # auto mode, use default min and max
   if [ $# -ne 1 ]; then
      [ $verbose = Y ] && echo "wrong number of args for auto mode" >&2
      usage
   fi
   
   echo "in 'auto' mode, we use putty_client_file=$putty_client_file"

   if ! [ -f "$putty_client_file" ]; then
      [ $verbose = Y ] && echo "ERROR: putty client file $putty_client_file does not exist" >&2
      exit 1
   fi

   # putty_client_file format is
   # login,ip min_pos max_pos
   # mylogin,192.168.1.62 0 2
   line=$(egrep "^$putty_login,$putty_ip\\s" $putty_client_file)
   
   # if there is a line, then we can set the putty position
   if [ "X$line" = "X" ]; then
      [ $verbose = Y ] && echo "ERROR: no putty client found in $putty_client_file for pattern='^$putty_login,$putty_ip'" >&2
      exit 1
   elif [ $verbose = Y ]; then
      echo "found putty client line: $line"
   fi

   min_pos=$(echo $line | awk '{print $2}')
   max_pos=$(echo $line | awk '{print $3}')
   # echo "puttypos $min_pos $max_pos"

   # recursively call this script with specific min and max
   [ $verbose = Y ] && echo "puttypos $flag $min_pos $max_pos"
   puttypos $flag $min_pos $max_pos
    
else
   # puttypos min max
   if [ $# -ne 2 ]; then
      echo "wrong number of args" >&2
      usage
   fi

   min=$1
   max=$2

   if [[ $min =~ [^0-9] ]]; then
      echo "ERROR: min='$min' is not a number" >&2
      usage
   fi

   if [[ $max =~ [^0-9] ]]; then
      echo "ERROR: max='$max' is not a number" >&2
      usage
   fi

   if [ $min -ge $max ]; then
      echo "ERROR: min=$min is not less than max=$max"
      usage
   fi

   # for loop range, works for numbers
   #    for i in {0..10} 
   # but not work for variables
   #    for i in {$min..$max}
   # for variables, use C-style instead
   for (( i = $min; i <= $max; i ++ ))
   do
      [ $verbose = Y ] && echo ""
      [ $verbose = Y ] && echo "checking spot $i"

      # pad the number in the file name to make 'ls /tmp/puttypos.*' easy to sort
      padded=`printf '%03d' $i`
      posfile=/tmp/puttypos.$user.$putty_ip.$padded 

      if [ -e $posfile ]; then
         pid=$( cat $posfile | cut -d' ' -f1 )
         [ $verbose = Y ] && echo "found posfile $posfile, pid=$pid"

         if ! [ "X$pid" = "X" ]; then
            if ps -p $pid >/dev/null; then
               [ $verbose = Y ] && echo "putty at position $i is running, pid=$pid."             
               if [ ${seen[$pid]+_} ]; then
                  # +_: This is a shorthand way to check if the key $pid exists in the seen array.
                  # when you use + with an array element, it evaluates to a non-empty string 
                  # (e.g., _) if the key exists, or an empty string if it doesn't.
                  [ $verbose = Y ] && echo "already seen pid=$pid in ${seen[$pid]}. use $i"
               elif [ "$putty_pid" = "$pid" ]; then
                  # this file has putty_pid
                  [ $verbose = Y ] && echo "seen putty_pid=$putty_pid in $posfile. keep spot $i"
               else
                  [ $verbose = Y ] && echo "we will check next spot"
                  seen[$pid]=$posfile
                  continue
               fi
            else 
               [ $verbose = Y ] && echo  "pid=$pid in $posfile is not running.  use sport $i"
            fi
         else
            [ $verbose = Y ] && "$posfile is empty. we can use sport $i"
         fi
      fi

      # found a spot
      offset=`expr 30 \* $i`

      # https://superuser.com/questions/1162451
      printf '\033[3;'"$offset;$offset"'t'

      echo $putty_pid > $posfile

      found=$i
      break
   done
      
   if [ "X$found" = "X" ]; then
      echo "$prog: no available spot found"
   else
      [ $verbose = Y ] && echo "spot found at $found"
   fi
fi

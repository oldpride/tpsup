#!/usr/bin/perl

use warnings;
use strict;
use Data::Dumper;
use Getopt::Long;
use strict;
use Carp;
use POSIX qw/strftime/;

my $prog = $0;
$prog =~ s:.*/::;

my $interval = 540;    # seconds

sub usage {
   my ($message) = @_;

   print "$message\n" if $message;

   print <<"END";
usage:

   $prog auto
   $prog long_tty
   $prog short_tty

   -v              verbose mode.
   -i interval     default to $interval

   To keep the terminal alive otherwise it would be timed out after 3600 seconds of idle.
   The check interval is $interval seconds.

   When use 'auto', the script will automatically pick the current tty.

   The script will exits after the command shell process exits (after the next check interval).

examples:

   $prog auto
   $prog /dev/pts/1
   $prog pts/1


END

   exit 1;
}

my $verbose;

GetOptions(
   'v|verbose'    => \$verbose,
   'i|interval=s' => \$interval,
) || usage("cannot parse command line: $!");

usage("wrong number of args") if !@ARGV;

my ($tty) = @ARGV;

# should only run on a linux host
my $osname = `uname -s`;
chomp $osname;
if ( $osname !~ /linux/i ) {
   $verbose && print STDERR "$prog quit because osname='$osname' is not linux\n";
   exit 0;
}

# make sure we have a real tty
my $long_tty = `tty 2>/dev/null`;
if ( !$long_tty ) {
   $verbose && print STDERR "$prog quit because we don't have a tty\n";
   exit 0;
}

chomp $long_tty;
my $short_tty = $long_tty;
$short_tty =~ s:^/dev/::;

# make sure that
#    1. this session is from a remote connection
#    2. there isn't another instance of this script running from the same remote ip.
# using 'who' command's output
# $ who
# tian    pts/1        2025-08-25 18:27
# tian    pts/2        2025-08-26 06:51 (::1)
# tian    pts/3        2025-08-26 07:01 (::1)
# tian    pts/4        2025-08-26 07:04 (::1)
# the above output was from WSL.
# on a linux host, the fourth column, inside the parenthesis, is the client ip address.

my $me = `whoami`;
chomp $me;
my $who       = `who`;
my @who_lines = split /\n/, $who;

my $ip_by_tty;
my $ttys_by_ip;
foreach my $line (@who_lines) {
   my ( $user, $tty, $date, $time, $ip_enclosuer ) = split /\s+/, $line;
   if ( $user eq $me ) {
      if ( $ip_enclosuer && $ip_enclosuer =~ /\((.+?)\)/ ) {
         my $ip = $1;
         # ip must be a remote ip, not localhost in IPv4 or IPv6 format
         if ( $ip !~ /^(127\.0\.0\.1|::1)$/ ) {
            $ip_by_tty->{$tty} = $ip;
            push @{ $ttys_by_ip->{$ip} }, $tty;
         }
      }
   }
}

if ($verbose) {
   print STDERR "ip_by_tty=",  Dumper($ip_by_tty);
   print STDERR "ttys_by_ip=", Dumper($ttys_by_ip);
}

# make sure this is a remote connection
my $this_tty_ip = $ip_by_tty->{$short_tty};
if ( !$this_tty_ip ) {
   $verbose && print STDERR "$prog quit because current connection is not a remote connection.\n";
   exit 0;
}

# make sure there isn't another instance of this script running from the same remote ip
my $ttys_for_this_ip = $ttys_by_ip->{$this_tty_ip};
for my $other_tty (@$ttys_for_this_ip) {
   next if $other_tty eq $short_tty;

   # check if there is another instance of this script running on $other_tty
   my $ps       = `ps -f -t $other_tty 2>/dev/null`;
   my @ps_lines = split /\n/, $ps;
   shift @ps_lines;    # remove header line

   for my $line (@ps_lines) {
      if ( $line =~ /\b$prog\b/ ) {
         if ($verbose) {
            print STDERR
"$prog quit because there is another instance of this script running on the same remote ip '$this_tty_ip' from tty '$other_tty'.\n";
            print STDERR "ps output on $other_tty=\n$ps\n";
         }
      }
   }
}

# now we should run the main loop

my $child_pid = fork();

if ($child_pid) {
   # this is parent
   exit 0;
} elsif ( $child_pid == 0 ) {
   # this is child

   my $hostname = `hostname`;
   chomp $hostname;
   my $id = `id`;

   my ($user) = ( $id =~ m:.+?\((.+?)\): );
   $user = 'unknown' if !$user;

   while (1) {
      # # user1@host1:/proc/15411-> ps -ef |grep alive
      # # user1 27203 16988 0 12:08:21 pts/11 0:00 /usr/xpg4/bin/grep alive
      # # user1 15411 1235 0 11:08:29 ? 0:00 /usr/bin/perl /home/user1/tpsup/scripts/tpalive /dev/pts/4
      # # user1 17227 1235 0 11:09:37 pts/11 0:00 /usr/bin/perl /home/user1/tpsup/scripts/tpalive /dev/pts/ll
      # # user1@host1:/proc/15411-> ps -p 15411,17227 -o tty
      # # TT
      # # ?
      # # pts/11

      # my $current_tty = 'tty 2>/dev/null';

      # if ( !$current_tty || $current_tty !~ /\// ) {
      #    # grand-parent shell process already exited, so will I
      #    exit 0;
      # }

      my ( $dev, $ino, $mode, $nlink, $uid, $gid, $rdev, $size, $atime, $mtime, $ctime, $blksize, $blocks ) =
        stat($long_tty);
      my $now = time();

      my $mstring = strftime( "%Y%m%d-%T", localtime($mtime) );

      my $now_string = strftime( "%Y%m%d-%T", localtime($now) );

      if ( $now - $mtime + $interval > 2 * $interval - 5 || $verbose ) {
         print STDERR "$now string we have to spit some message to keep this terminal alive. ",
           "tty=$tty, stamp=$mstring, pid=$$, host=$hostname, user=$user, interval=$interval\n";
      }
      sleep $interval;
   }
}

exit 0;

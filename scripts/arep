#!/usr/bin/env perl

use warnings;
use strict;
use Data::Dumper;
use Getopt::Long;
use Carp;
use TPSUP::AUTOSYS qw(get_dependency 
                      query_jobs_superset
                      autorep_J
                      get_autorep_J_format
                      print_autorep_J_header
                      print_autorep_J_job
                      print_autorep_q_J_job
                      print_job_csv
                      resolve_jobs
                      parse_cmdline_jobs
                      );
use TPSUP::UTIL    qw(get_in_fh close_in_fh);
# use Carp::Always;

my $prog = $0; $prog =~ s:.*/::;

my $DetailExpire = 300;
my $StatusExpire = 15;

sub usage {
   my ($message) = @_;
   print "$message\n" if $message;

   print << "END";
usage:

   $prog [-q] joblist1.txt joblist2.txt ...
   
description:

   Run autorep for jobs listed in a file, joblist.txt. Within the file, one job per line.
   The file allows comments (#) and blank lines.

   -xp ExcludePattern  perl regex pattern, exclude job matched this pattern, case insensitive
                       this is to filter input file

   -mp MatchPattern    perl regex pattern, only run job matching this pattern, case insensitive
                       this is to filter input file

   -me MatchExpression perl regex, eg, -me '\$Status !~ /OH|OI/'. can set multiple times

   -de n               expire Detail cache after n seconds. default $DetailExpire.
                       mainly for testing purpose.

   -se n               expire Status cache after n seconds. default $StatusExpire.
                       mainly for testing purpose.

   -r                  reset cache, ie, time out all caches

   -noExpire           use existing cache if exists, try not to expire it. used during test.

   -df DetailFiles     Use DetailFiles instead. multiple filenames separated by coma.

   -sf StatusFiles     Use StatusFiles instead. multiple filenames separated by coma.

   -J                  args are jobnames. default to filenames

   -n                  dryrun mode, check-only. will print the command but won't run the jobs.

   -c tag1,tag2,...    validate these tags are defined. for troubleshooting purpse
                       for example, -c defination,LastStart,LastEnd

   -csv tag1,tag2,...  print in csv format
   -delimiter string   delimiter when -csv is used. default to ','

   variables are: \$JobName \$job_type \$LastStart \$LastEnd \$Status ...
   basically any autosys tags.

examples:

   $prog abatch_test.txt   # take from file
   $prog -                 # take from STDIN

   - test without autosys
   $prog    -df adep_autorep_q_J_example.txt -sf adep_autorep_J_example.txt abatch_test_fatal.txt
   $prog -q -df adep_autorep_q_J_example.txt -sf adep_autorep_J_example.txt abatch_test_good.txt

   - test wildcard
   $prog -df adep_autorep_q_J_example.txt -sf adep_autorep_J_example.txt -J test\%
   $prog -df adep_autorep_q_J_example.txt -sf adep_autorep_J_example.txt -J test\%2 test_job2

   - test MatchExpression, ie, 'agrep sleep test\%'
   $prog -df adep_autorep_q_J_example.txt -sf adep_autorep_J_example.txt -me '\$defination =~ /sleep/' -J test\%
    
   - test -csv 
   $prog -df adep_autorep_q_J_example.txt -sf adep_autorep_J_example.txt \\
         -me 'defined \$watch_file' -csv JobName,watch_file \\
         -J test%

   $prog -df adep_autorep_q_J_example.txt -sf adep_autorep_J_example.txt \\
         -me 'defined \$watch_file' -q \\
         -J test% |egrep "insert_job|watch_file"

END


   exit 1;
}

my $verbose;
my $MatchPattern;
my $ExcludePattern;
my @JobExps;
my $DetailFiles;
my $StatusFiles;
my $detail;
my $reset;
my $noExpire;
my $arg_is_job;
my $check_tags;
my $csv_fields;
my $csv_delimiter = ',';

GetOptions(
   'v|verbose'     => \$verbose,
   'r|reset'       => \$reset,
   'noExpire'      => \$noExpire,
   'q'             => \$detail,
   'mp=s'          => \$MatchPattern,
   'xp=s'          => \$ExcludePattern,
   'me=s'          => \@JobExps,
   'df=s'          => \$DetailFiles,
   'sf=s'          => \$StatusFiles,
   'de=s'          => \$DetailExpire,
   'se=s'          => \$StatusExpire,
   'J'             => \$arg_is_job,
   'c=s'           => \$check_tags,
   'csv=s'         => \$csv_fields,
   'delimiter=s'   => \$csv_delimiter,
) || usage("cannot parse command line: $!");

usage("wrong number of args") if ! @ARGV;

my ($jobs, $seen, $jobFlags) 
   = parse_cmdline_jobs(\@ARGV, {
                                         JFlag=>$arg_is_job,
                                  MatchPattern=>$MatchPattern,
                                ExcludePattern=>$ExcludePattern,
                        });

$verbose && print "jobs = ", Dumper($jobs);

my $opt = {
   DetailExpire => $DetailExpire,
   StatusExpire => $StatusExpire,
   DetailFiles  => $DetailFiles,
   StatusFiles  => $StatusFiles,
   JobExps      => \@JobExps,
   verbose      => $verbose,
};

my $is_status_attr = {
    LastStart => 1, 
    LastEnd   => 1,
    Status    => 1,
};
      
if ($detail) {
   $opt->{DetailOnly} = 1;
} else {
   $opt->{StatusOnly} = 1;
}

if ($csv_fields) {
   my @fields = split /,/, $csv_fields;

   for my $var (@fields) {
      if ($is_status_attr->{$var}) {
         $opt->{DetailOnly} = 0;
      } else {
         $opt->{StatusOnly} = 0;
      }
   }
} 

if (@JobExps) {
   $opt->{NotFoundMsg} = 'not match';

   for my $je (@JobExps) {
      # this may not be accurate
      my @vars = ($je =~ /\$([a-zA-Z_-]+)/g);
   
      for my $var (@vars) {
         if ($is_status_attr->{$var}) {
            $opt->{DetailOnly} = 0;
         } else {
            $opt->{StatusOnly} = 0;
         }
      }
   }
}

if ($check_tags) {
   @{$opt->{ValidateVars}} = split /,/, $check_tags;
}

my $info;
if ($reset) {
   my $opt2 = {%$opt};
   $opt2->{DetailExpire} = 0;
   $opt2->{StatusExpire} = 0;
   $info = query_jobs_superset($seen, $opt2);
} elsif ($noExpire) {
   my $opt2 = {%$opt};
   $opt2->{DetailExpire} = 3600*24*365;
   $opt2->{StatusExpire} = 3600*24*365;
   $info = query_jobs_superset($seen, $opt2);
} else {
   $info = query_jobs_superset($seen, $opt);
}

#my $exists_box_job;
#
#for my $job (keys %$info) {
#   my $box_name = $info->{box_name};
#
#   if ($box_name) {
#      $exists_box_job->{$box_name}->{$job} ++;
#   }
#}

$verbose && print "info = ", Dumper($info);

my @superset = sort(keys(%$info));

$verbose && print "superset = ", Dumper(\@superset);

my $resolved_jobs = resolve_jobs($jobs, \@superset, {
                                                       MatchPattern=>$MatchPattern,
                                                     ExcludePattern=>$ExcludePattern,
                                                     WithinSuperset=>1,
                                                    }
                                );

$verbose && print "resolved_jobs = ", Dumper($resolved_jobs);

if ($csv_fields) {
   my @fields = split /,/, $csv_fields;

   print join($csv_delimiter, @fields), "\n";

   for my $job (@$resolved_jobs) {
      print_job_csv($info, $job, \@fields, $opt);
   }  
} elsif ($detail) {
   for my $job (@$resolved_jobs) {
      print_autorep_q_J_job($info, $job, "", $opt);
   }  
} else {
   # status only
   print_autorep_J_header();

   for my $job (@$resolved_jobs) {
      print_autorep_J_job($info, $job, "", $opt);
   }
}

exit 0;

